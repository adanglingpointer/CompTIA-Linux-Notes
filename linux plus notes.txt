Linux Distributions
-------------------

most distros are based off of four main branches

	- Arch
		- Manjaro
		- EndeavourOS
	- Red Hat
		- Conectiva
		- Mandrake
		- Mandriva
		- Mageia
		- Fedora
		- CentOS Enterprise Linux
		- Rocky Enterprise Linux
		- CloudLinux OS
	- Slackware
		- S.u.S.E. SuSE
		- SUSE
		- OpenSUSE
		- SLAX
		- VectorLinux
	- Debian
		- Ubuntu
		- Linux Mint
		- Kali

Slackware
	- one of the earliest distributions
	- created in July 1993
	- designed for advanced users
	- uses pkgtools package management system
	- SUSE was based off of Slackware originally, however now bares little resembles and uses RPM (from Red Hat)

Debian Linux
	- Named for Debra and Ian Murdock
	- released in December 1993
	- maintained by a community
	- not associated with any corporation
	- maintainers and project leaders are elected
	- stresses importance of freedom
	- only includes free software (free as in freedom)
	- non-free software can be installed
		i.e., software that doesn't comply with Debian free software guidelines
	- uses Advanced Package Tool (APT)
	- six of top 10 distros on distrowatch.com are based on Debian

Red Hat
	- early commercial distribution
	- November 1994
	- went public in 1999
	- first billion-dollar open-source company in 2012
	- Red Hat has majority of the commercial Linux server market share
	- uses Red Hat Package Manager (RPM)

Arch
	- created in early 2000s
	- simple and lightweight
	- uses the pacman package manager

==========

 - Install
 - Reboot
 - Login

 - For the best experience you will want to install virtual box guest editions in your virtual machine.
 - This will allow full screen and seamless mouse.

sudo dnf update -y
sudo reboot
sudo dnf group install -y "Development tools"
sudo dnf install -y kernel-devel

sudo hostnamectl set-hostname whatever.localhost

-

sudo apt install -y build-essential linux-headers-$(uname -r)

==
Filesystem Hierarchy Standard
-----------------------------

/ (known as slash, root directory, or top level directory)
	/bin	= essential user command binaries (for use by all users)
		simple commands such as ls and cat
	/sbin	= utilities used for system administration
		command binaries essential for booting, restoring, recovering, and/or repairing the system,
		in addition to the binaries in /bin
	/boot	= bootloader files
		everything required for the boot process except configuration files not needed at boot time
		(config files for bootloaders not required at boot time must be placed in /etc) 
	/dev	= stores device files - an interface to the system's hardware through a device drive
		can also be input/output characters that act as if they were devices
	/etc	= contains static configuration files
		files should be stored in subdirectories
		can not be executable binaries
	/home	= home directory for regular users to store their personal files
		store one directory per user
	/lib	= shared library images needed to boot the system and run commands in the filesystem,
		such as those in /bin and /sbin
		system libraries and kernel modules
		may be diff lib folders, such as /lib64
	/media	= mount point for removable media
		cd-roms, external USB drives, etc.
	/mnt	= mount points for temporarily mounted filesystems
		such as a network drive
	/root	= home directory for the root user, for personal files
	/opt	= optional software
		reserved for the installation of add-on application software packages
		often, software that is not distributed in a Linux software package format will be installed here
	/proc	= a virtual filesystem, files do not really exist on the disk
		used for storage and retrieval of process information, as well as other kernel and memory info
	/srv	= store site-specific data, for example virtual hosts or by protocol
	/sys	= store info about devices connected to computer, another virtual file system
	/tmp	= temporary files
	/run	= system information data describing the system since it was booted
		these files must be cleared at the beginning of the boot process
	/usr	= essential user command binaries (for use by all users)
		read only, not written to unless installing new software
	/usr/bin	= primary directory of executable commands on the system
			on some systems, /bin is a link to this directory
	/usr/local	= hierarchy for installing software locally
			usually not through software package manager
			needs to be safe from being over-written when system software is updated
	/usr/sbin	= nonessential binaries used exclusively by the system admin
			system repair, system recovery
			on some systems, /sbin links here
	/usr/share	= a hierarchy for read-only architecture independent data files
			for example, a site with 386 Alpha Empire PC platforms might maintain a single /usr/share 
				directory that is centrally mounted
			icons, wallpaper, etc
	/usr/src	= source code may be placed in this subdirectory only for reference purposes
	/var	= contains variable data files
		including spool directories and files, administrative and login data, transient and temp files
		a system log file, a mail spool
	/var/cache	= application cache data
			the app must be able to regen, so this is generally safe to delete
	/var/log	= contains miscellaneous log files
	/var/spool	= contains data that is awaiting some kind of later processing
			print spools, outgoing mail spools, etc.
	/var/mail	= user mailbox files
	/var/lib	= holds state information pertaining to an application or the system
			such as lock files

Where in the Linux Filesystem Hierarchy is most of the Linux operating system installed?
/usr stores the majority of all Linux commands and tools. In some distributions /bin and /sbin are actually links to directories in /usr.

-

grep --help
help cd
man man-pages

-

mkdir -p parent/child

mkdir {dir1,dir2,dir3}
mkdir dir{1,2,3}
touch file{a,b,c}.txt

echo "A new line" >> textfile.txt

-

cat >> textfile.txt
This is a new line
	ctrl+d to save it

cp -a
	preserves all metadata
cp -u
	only copies if newer
cp -R
	recursive (folders)
cp -i
	interactive, ask before overwriting

rmdir
	only empty folders
rm -r
	remove directory with files
rm -ir
	interactive
rm file{c,d}.txt
	removes filec.txt and filed.txt

cd -
	a shortcut to return to the previous directory

==

create links

symbolic link vs hard link

hard links:

ln whatyourelinkingto.txt whatyouwanttocallthelink.txt

Hard links create another name that points to the same data blocks that even have the same index or inode number.

advantages of hard links:
	takes up virtually no space
	doesn't break when target is deleted
	performance

disadvantages:
	can only hard link files and not directories
	can not link across file systems (different drives or partitions)
	transparent so difficult to identify
	must remove all inodes (index nodes) to delete hard links

ls -l
	usually files have 1 inode, so if it's 2 this is a hint it's a hard link

can compare two different files if they point to the same inode with stat
stat file.txt
stat filelink.txt

symbolic link:

ln -s file.txt filesymlink.txt

ls -l
	will show a symbolic link as
	lrwxrwxrwx. 1 user1 user1 8 Apr 17 03:37 filesymlink.txt -> file.txt
	-rw-rw-r--. 2 user1 user1 0 Apri 17 03:33 file.txt
the permissions on the real file are enforced (not symbolic link excessive permissions)

removing the original file will cause the symbolic link to break (show red in ls -l)
the inode on hardlink will remain but show as 1 with ls -l

advantages of symbolic links:
	can link across file systems
	can link to directories
	easy to identify

disadvantages of symbolic links:
	takes up space (small)
	breaks if target is deleted
	not seamless - commands may act differently when dealing with a symbolic link

pro tip:
ln -s archive/ dirlink
rm dirlink/
	this will delete the directory archive, not the link
	instead, remove the trailing /
	[didn't work for me on Debian]
rm dirlink

==========

I/O redirection

3 streams are created by a Linux shell when a command runs

STDIN	->	command	->	STDOUT
			->	STDERR

Function	Name	File Descriptor #
Input		STDIN	0
Output		STDOUT	1
ERROR OUTPUT	stderr	2

Command output methods:
Pipes - Takes output of a command and sends to the input of another
Redirects - Takes output of a command and sends to a file in the file system

Pipes
Command	->	STDOUT	->	Pipe	->	STDIN	->	Command

Redirects
Command	->	STDOUT/STDERR	->	&>	File

grep tcp /etc/services | less
This uses the grep command to search through the /etc/services file for the word tcp and sends the output to the less command, which displays it one page at a time. (press q to quit)

grep tcp /etc/services | awk '{print $1}' | sort | less
This uses the grep command to search through the /etc/services file for the word tcp and then sends the resulting lines to the awk command, which only prints the first column. Then sends the remaining output to the sort command which sorts in dictionary order and finally sends it to the less command to show one page at a time.

unnamed pipe is the default
named pipe - FIFO = First In First Out
	can pipe commands between terminals

Command	->	/home/mypipe	->	Command

a named pipe exists in the file system, that acts like a file on the disk

terminal one:
mkfifo named_pipe
echo "Hi" > named_pipe

terminal two:
cat named_pipe
	// Hi

==========

File redirects and tees
-----------------------

find > myfiles.txt
List all files in the current directory, saves STDOUT to myfiles.txt

find 2> myfiles-err.txt
Redirect STDERR to a file

find > myfiles.txt 2> myfiles-err.txt
Also works

find &> alloutput.txt
Redirect STDERR and STDOUT to a file

These all overwrite file.  We can instead append to end of file with >>

find >> myfiles.txt
find 2>> myfiles-err.txt
find &>> alloutput.txt

Redirect a file to STDIN:
mysql -u user1 p db_name < db.sql

Redirect to STDIN then output STDOUT and STDERR
mysql -u user1 p db_name < db.sql > out.txt 2> outerr.txt

tee splits output between a file and the sceen

Redirect STDOUT to a file and to the screen:
find | tee myfiles.txt

Append STDOUT to a file and to the screen:
find | tee -a myfiles.txt

Pipe only receives STDOUT by default, so we can combine STDOUT and STDERR into one stream.

Pipe STDERR and STDOUT to a command:
find 2>&1 | grep example.txt

2> redirects STDERR to &1 which is STDOUT.  This merges both STDERR and STDOUT and outputs on file descripter 1 (STDOUT). Then it pipes to grep to search it.

Newer versions of bash accept this alternative syntax:
find |& grep example.txt

This also does the same thing, redirecting STDERR and STDOUT to STDOUT.

-

Pipe only STDERR to a command:
find 2>&1 >/dev/null | grep example.txt

First it redirects STDERR on file descriptor 2 to STDOUT on file descriptor 1.  Then it redirects the original (old) STDOUT to /dev/null (oblivion!) so it doesn't get sent to the pipe.  Only STDERR gets send through the pipe to grep.

==

Find files using locate
-----------------------

locate uses a database created by the updatedb command.  it is fast but only finds files listed in database.  a system service updates once/day.

locate bzip2

print a number of how many results will be found:
locate -c bzip2

search for two items:
locate bzip2 man

search for items that contain both items/search terms:
locate -A bzip2 man

case insensitive searching:
locate -i high

wildcards with ls:
ls /etc/*.conf

regular expressions:
locate --regexp '^/usr.*pixmaps.*jpg$'

Find all paths that start with /usr, include the word pixmaps, and end with jpg.
^ anchors to the beginning of the line
.* matches any number of any characters
$ anchors to the end of the line

regular expresions for finding more than one:
locate --regex '^/usr.*{pixmaps|backgrounds}.*jpg'
	[doesn't work for me]

this includes results for pixmaps or backgrounds

locate -S
List statistics of locate's database

=====

find command
------------

doesn't rely on database, so always up to date

sudo find / -name *bash*

sudo find / -not -iname *bash

-not = does not include
-iname = case insensitive

with find we can also use:
-f = file
-d = directory
-l = symbolic link
-c = character device
-b = block device

sudo find / -type f -name *bash*

can also search for more than one type at a time:

sudo find / -type f,d -name *bash*

find also works with -regex

Finding files by size:
find /usr -size +10M
	shows all files more 10MB

Signifier	Unit of Measurement
c		Bytes
k		Kilobytes
M		Megabytes
G		Gigabytes
b		512-byte blocks

We can also specify -empty for empty files:
find /usr -size -empty
(doesn't work for me)

Option		|File Type
-amin		|Last accessed (by minutes)
-atime		|Last accessed (by days)
-cmin		|Last changed (by min)
-ctime		|Last changed (by days)
-mmin		|Last modified (mins)
-mtime		|Last modified (days)

find / -atime 1
find / -atime -1
find / -atime +1

Find files that belong to a certain user or group:
sudo find / -user user1

We can also use find to search by permissions:
-readable
-writable
-executable

or numeric permissions:
-perm 644 [find by exact permissions]
-perm -644
-perm /644

or symbolic permissions:
-perm u=rw,g=r,o=r [find by exact permissions]
-perm -u=rw,g=r,o=r
-perm /u=rw,g=r,o=r

Find by exact permissions:
-perm 644
-perm u=rw,g=rw,o=r
 matches: -rw-rw-r--.

Find by all of the specified permissions:
-perm -664
 matches:	-rw-rw-r--
		-rw-rw-rx
will match all files with at least rw- rw- and r--, this would also match a file with 665 permissions, because that file would also have 664 in addition to execute.

Find by any of the specified permissions:
-perm /644 [was written with a + in the past, but this is no longer recommended]
will match files with any combition of rw-, r--, and r--
 matches	-rw-------.
		----r-----.
		-------r--.

Combining permissions can become complex.

find / -perm -a+r -perm /a+w \! -perm /a+x
This will find files that are readable by everyone [ -perm -a+r ],
at least one write bit is set [ -perm /a+w ],
and not executable by anyone [ \! -perm /a+x ]

Finding by SELinux security context using the -context option:
find / -type f -context '*ifconfig_exec_t*'
context is matched using pattern matching

Find can also perform a function with the files.

Action		Function
-print/-printf	Display output
-delete		Dlete matching files
-ls		List metadata of files
-prune		Omit matching files
-exec		Execute command for each

For example, executing an external command:
find / -size +1M -exec stat -c "%s %n" {} \;
This searches for files larger than 1MB [ -size +1M ],
and then runs the stat command on each file which outputs the size and name [ -exec stat -c "%s %n" ].
The curly braces are a placeholder for each search item's name which is passed to the stat command {}
\; tells find there are no more commands to run.

Other examples:

Find files with certain permissions and change them:
find / -type f -perm 644 -exec chmod 664 {}\;

Move .tar.gz files in /logs older than 7 days and move them into /backups:
find /logs -name "*.tar.gz" -mtime +7 -exec mv {} /backups \;

=====

nano
----

nano -u nanofile.txt
	opens a file with undo feature enabled

ctrl+g = guide/help
	ctrl+x to exit guide
ctrl+o = write file changes out to disk
ctrl+r = insert another file's contents into current document
ctrl+k = cut line of text
	pressing multiple times adds to cut 'stack' until pasted
alt+6 = copy text
ctrl+u = uncut/paste
ctrl+6 = begin marking text/highlight
alt+u = undo
alt+e = redo
ctrl+w = search through text (where)
alt+r = find & replace
alt+c = turn on/off line numbering (count)
ctrl+alt+- = go to line number

=====

vim
---

vim vimfile.txt
	open file with vim

normal mode & insert mode

normal mode - characters you type are commands
insert mode - characters inserted as text

i
	switch to insert mode

esc
	switch back to normal mode

in normal mode:

hjkl shortcuts
	h = left
	j = down
	k = up
	l = right

6l = move right 6 character

w = move forward by whole word
b = move back by whole word
^ = move to beginning of line
$ = move to end of line

shift+h = beginning of file
shift+m = move to middle of file
shift+l = last line of file

dl = delete character (same as delete key)
dd = delete line

u = undo
ctrl+r = redo

escape+: = command line mode
	w = write changes to disk
	w newfile.txt = save changes to new file
	q = quit
	q! = force quit (without saving changes)

	can stack as wq

yl = copy a letter
yw = copy a word
yy = copy a line
p = paste/put
dl = cut/delete letter
dw = cut/delete word
dd = cut/delete line

5dd = cut 5 lines
etc..

cc = cut line and immediately enter edit mode

/ = search from current position down
? = search from current position upward
	press enter and then,
	n = step forward through results
	N = step backwards through results

:nohl
	turn off search highlighting

:%/Line/Newline
	replace Line with Newline
	[doesn't work for me]

vim file1.txt file2.txt file3.txt
	open multiple files at once

:next
	next file
:prev
	previous file
:wnext
	save and move to next doc
:wprev
	save and move to prev doc
:2next
	move 2 docs first
:args
	list documents open

==========

find text in files with grep
----------------------------

grep root /etc/passwd
	search for root in /etc/passwd

run two commands in a row, second one after the first finishes, whether the first finished successfully or not:
	echo "hi" ; echo "there"
	// hi
	// there

only run the second command if the first succeeds:
	mkdir newfolder && cd newfolder

only run the second command if the first fails:
	mkdir newfolder || echo "directory creation failed"

cd into new folder, otherwise echo error message:
mkdir newfolder2 && cd newfolder2 || echo "Directory creation failed"

cd
	by itself, brings you to your home directory

{ echo "hi" ; echo "there" ; }
	hi
	there

echo "hi" ; echo "there" > hello.txt
	hi
cat hello.txt
	there

{ echo "hi" ; echo "there" ; } > hello.txt
cat hello.txt
	hi
	there

curly braces force bash to process all commands inside the braces as one command

( echo "hi" ; echo "there" ; ) > hello.txt
cat hello.txt
	hi
	there

curly braces - run commands in the same hell
parentheses - run commands in a subshell, they will have different variable scope

a=0; (a=10; echo "in=$a"); echo "out=$a"
	in=10
	out=0

==========

Edit text with sed
------------------

sed is a stream editor - it edits text as it passes through
- uses basic regular expressions by default
- optionally uses extended regular expressions

sed modes
---------
mode		function
----		--------
print		prints text like grep
delete		deletes matched text
substitute	finds and replaces

by default sed prints out all output, so use -n to only print those that match a pattern

sed -n '/pattern/p'

-E for extended regular expressions
	sed -n -E '/ERE regex/p'
the trailing p is the print command

piping into sed:
	cat /etc/passwd | sed -n '/pattern/p' > newpasswd
you cannot redirect back to the original file or the file will end up being blank

loading a file into sed
	sed -n '/pattern/p' /etc/passwd > newpasswd

you can specify the -i option to change the file in place:
	sed -n -i '/pattern/p' /etc/passwd

deleting in sed, with /d:
	sed '/pattern/d'

	sed -E '/ERE regex/d'

substituting in sed with s:
	sed 's/pattern/pattern/g'
	/g is to match globally

printing a range of lines:
	sed '5,10p'

deleting a range of lines:
	sed '5,10d'

substituting for a range of lines
	sed '5,10s/pattern/pattern/g'

pattern delimiters

/home/user1/Downloads/
	sed 's/\/home\/user1\/Downloads\//pattern/g'
we can use backslashes to escape forward alshes

a possibly better solution: sed's ability to replace forward slash delimeter with another character

/home/user1/Downloads/
	sed 's#/home/user1/Downloads/#pattern#g'

# sed -n '/root/p' passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

# sed -n '/^root/p' passwd
root:x:0:0:root:/root:/bin/bash

# sed -n 's/^root/toor/p' passwd
toor:x:0:0:root:/root:/bin/bash

Using regexes in sed
--------------------

sed -E 's/:([0-9][0-9]{0,2}):/:uid:/' passwd
	This matches a colon followed by one instance of a number from zero through nine
	and a second number from zero to nine, either zero, one, or two times as specified by the modifier
	in curly braces {0,2} and then another colon.
	This expression will match a colon, a number from zero to 999, followed by another colon,
	and replace it with a text :uid:

You can also delete patterns by substituting with nothing:
	sed -E 's/:([0-9][0-9]{0,2})://' passwd

surrounding phone number area code with parentheses:
	sed -E 's/[0-9]{3}/(&)/' phonenumbers.txt
this will repeat the first set of three numbers (using the & symbol) and surrounds it with parentheses ( )

using Back References in sed, we can group patterns with parentheses:
	sed -E 's/([0-9]{3})([0-9]{3})([0-9]{4})/(\1)\2-\3/' phonenumbers.txt

examples: sed.sourceforce.net/sed1liners.txt

=====

Linux Boot Process
------------------

1. Firmware stage
2. Bootloader stage
3. Kernel stage
4. Initialization stage

Firmware stage
 - Power-On Self-Test (POST)
 - executes code in the BIOS for legacy systems
 - executes code in the UEFI firmware for new computers
 - starts bootloader

Bootloader stage
 - firmware executes bootloader (grub2) code on drive
 - bootloader reads its configuration file
 - in BIOS machines, grub usually reads in /boot/grub2/grub.cfg, for EUFI systems the location can vary
 - executes the kernel

Kernel stage
 - kernel loads the RAM disk into RAM
	this RAM disk serves as a temporary root file system
 - kernel loads device drivers and config files from RAM disk
	this file system includes kernel modules, drivers, and possibly even installation automation files,
	such as kickstart files
 - kernel unmounts RAM disk and mounts root file system
 - starts initialization stage

Initialization stage
 - grandfather process (systemd) is started by the kernel
	in older versions of Linux this was the sys 5 INIT process
	INIT was replaced by Upstart in many distributions such as Red Hat and Ubuntu
	and now Upstart has been replaced by systemd
 - systemd starts system services
 - systemd starts login shells and GUI interface

systemd has the concept of 'targets' that are similar to the old sys 5 INIT run levels
you can think of a target as a system configuration
for instance, by default, Enterprise Linux boots into the graphical target
a system can be booted into different targets
there are targets for different purposes, such as rescuing a system after a crash

==========

Linux boot loaders and sources
------------------------------

LILO Bootloader
 - the original bootloader
 - boots Linux from hard drives
 - static config - /etc/lilo.conf
 - config changes needed to be written to the MBR
 - used Linux device naming conventions
 - development stopped in 2015 and most distributions do not use it

Grand Unified Bootloader
 - GRUB 0.97 / grub-legacy
 - GNU project - not Linux specific
 - does not use Linux device names
	it starts counting from 0, so /dev/sda1 might be drive 0,0
 - static config file in /etc
 - writes to MBR once, not everytime the config changes
 - did not support RAID, logical volumes, or new file systems

GRUB 2
 - default bootloader for Linux
 - automatically created configuration
	it can gather info about the system and create the config file accordingly
 - modular and expandable
 - built-in console allowing you to manage boot environments before the OS has even loaded
 - supports live boot and ISO images

alternative bootloaders
	ISOLINUX
		boots Linux from ISO optical disks
		a derivative of SYSLINUX
	SYSLINUX
		boots Linux from FAT formatted disk storage
		floppy disks and USB thumb drives
	PXELINUX
		also a derivative of SYSLINUX
		boots Linux from PXE network server using a network ROM conforming to Intel pre-boot execution
		 environment (PXE).

==========

GRUB 2
------

 - scripting
 - dynamic module loading
 - custom menus and themes
 - UUID for storage locations
 - recovery console

/boot
	the kernels named vmlinux are compressed bootable kernels
	the RAM disk will either be named initrd if your Linux system has a kernel older than 2.5, 
	 or intitramfs if the kernels is newer than 2.6.
	initrd acts as a disc that's in RAM but requires a driver to be compiled into the kernel
	initramfs has the advantage that it's not a disk but rather a file system and can be extracted and used
	 quicker.

to manually create a rescue RAM disk (for example, to include a custom device driver) you can use the
 'mk initrd' for older systems, or 'draca' for newer ones
draca is more powerful and included with Enterprise Linux

/boot/grub2/grub.cfg
	config that is over-written by grub2, so don't edit

/etc/default/grub
	grub menu timeout and kernel options

(
sudo su -
	switches to root user
)

/etc/grub.d
	this is a directory
	contains README
	files starting with 00 are reserved
	boot entries should start with 10, third party apps start with 20

30_os-prober looks for other installed operating systems and adds a menu option

installing grub bootloader
--------------------------
lsblk
	list your drives
sudo grub2-install /dev/sda
	install grub on first drive
sudo grub2-mkconfig
	after making any grub config changes to recreate boot files in /boot

grub2-reboot
	reboot into a specific kernel one time
grub2-set-default
	set default kernel

==========

rescue a system
---------------

kernel panic
	missing drivers
	bad drives

two ways to handle:
	boot into older kernel
	boot into different systemd target

grub2-set-default 1
	change default to most recent previous kernel
	grub starts counting from 0, so newly installed non-functioning kernel would be 0

systemd emergency target
	requires root password
	does not:
		load drivers
		start services
		start GUI
		mount/read-write

in grub, select most recent kernel and press 'e' key to edit
find the line that includes the word vmlinux, this is the kernel line and the items after are kernel parameters
press End to go to end of line, add a space and add
	systemd.unit=emergency.target
press ctrl+x to finish booting

journalctl -xb
	view all journald messages for this boot
dmesg
	the debug message command, similar output
	alternative to journalctl, also works for older systems that do not use systemd
dmidecode
	info about bios and hardware
mount
	show mounted volumes

in emergency mode, the route partition / will be read only
mount -o remount rw /
	remount root as read/writable

ctrl+d to exit, system will continue to boot

-

if you don't have the password or need password recovery, you'll need a different method

	[ these instructions break my system ]

reboot, and press e on kernel in grub again
at the end of vmlinux line, add:
	init=/bin/sh
press ctrl+x to boot up

mount -o remount rw /

passwd root
	reset root password, won't ask for existing pass

touch /.autorelabel
	SE Linux rewrite the security context of all files on the next reboot
/usr/sbin/reboot -f
	force reboot via full command location

login to system, switch to root to make sure it works
	su

-

to persistently boot into a different systemd target, you use the systemctl command

sudo systemctl get-default
	show default target
sudo systemctl --type=target --all
	show all possible targets

targets include:
	emergency.target
	graphical.target
	multi-user.target

sudo systemctl set-default graphical.target
	change default systemd target

==========

Linux processes
---------------

process - an instance of a program that is being executed on a CPU from memory

process resources:
	- memory
	- CPU time
	- Process ID (PID)

process ID tree:
	- every process has an ID
	- each process also has a parent process that started it
	- processes can spawn child processes

systemd(1)	-	{sshd}(1294)
		-	{sshd}(1304)
		-	{sshd}(1395)	-	sftp-server(6964)
					-	sftp-server(6962)

systemd is sshd's parent process
systemd is the only process that the kernel starts directly, the grandfather process

==========

monitor processes using ps
--------------------------

ps
	shows processes ran by the user executing it

ps has 3 types of syntax options:
	- UNIX
		-c
	- BSD
		c
	- GNU
		--command

ps -e
	display every process, even those ran by other users
ps -eH
	hierarchy options shows you which processes start other processes
ps -ef
	show more info about all processes (full option)
	includes start time, CPU utilization, start time, and command arguments with options
ps -eF
	shows more info like -f but also adds allocated memory to the total memory size, 
	 and the CPU the process is currently running on
ps -elF
	shows even more info (long format)
	17 columns of information

ps -e --format uid,pid,ppid,%cpu,cmd
	shows uers, PID, parent PID, CPU, and command name ran for all process
ps -e --format uid,pid,ppid,%cpu,cmd --sort %cpu
	sort by CPU utilization from least to greatest
ps -e --format uid,pid,ppid,%cpu,cmd --sort -%cpu
	sort by greatest to least

ps -U root
	show processes ran by root user
	-u to specify user ID
ps -C firefox
	show specific processes

ps -e --format uid,pid,tty,%cpu,cmd --sort %cpu
	shows every process, the user ID, the process ID, the terminal they were run on, the CPU utilization,
	 and the command name sorted with the highest CPU utilization at the bottom

ps -e --format uid,pid,tty,rss,cmd --sort rss
	sort by MEM usage
	good for finding processes using the most memory

ps -U user1 --format %mem | awk '{memory +=$1}; END {print memory}'
	this sends the memory usage of each program that user1 ran to awk,
	 which sums them and prints the total on the screen

we can also use $USER to substitute for the user running the command

shell script for the same thing:

//showusermem.sh

#!/bin/bash
ps -U $1 --format %mem | awk '{memory +=$1}; END {print memory}'
	$1 takes the first argument passed to the script
	make the script executable:
		chmod u+x showusermem.sh
	run with the user as an argument:
		./showusermem.sh user1

if you don't want to provide the path to the script every time you run it, then place it in a
 directory in your path variable, such as the bin directory in your home if you have one

==========

Monitor processes in real time
------------------------------

top

	- press l to show or hide the load average/uptime
	- press 1 to show CPU usage for all CPU cores
	- press t to toggle between task and CPU states
	- press m to toggle between different memory displays, or turn memory stats off
	- press f to change which fields to display
		press Space on the field you want to toggle
		press s on the field you want to sort by
		press -> to select a field in order to move it up or down, press <- to set it in place
		press q to quit the field menu
	- press c to toggle between command name and command line (location)
	- press U, followed by username, to only show processes by that user
		leaving username blank shows all users
	- press u to specify by user ID
	- press k for the kill prompt
		then you will be prompted for a PID to kill
		you can also specify a kill signal, SIGTERM/Signal 15 is the default
		SIGTERM is the friendly way of killing a process
		SIGKILL forcibly removes the process from memory, uses number 9
		press Esc to cancel kill prompt
	- press r for the renice prompt
		will prompt for PID to renice
		higher number = nicer on CPU = less CPU priority for process
	- press M to sort by memory usage
	- press P to sort by CPU usage (processor)
	- press T to sort by the amount of time a process has been running
	- press N to sort by process ID number
	- press q to quit top

htop
	has some additional features
	can click
	f6 to change sorting order

==========

Manage processes
----------------

pgrep firefox
	will print the main PID of firefox
pidof firefox
	will print all PIDs related to firefox
pstree -p
	show all running processes in a tree format with PIDs
kill -l
	list all possible kill signals you can send
	generally you want to send a non-destructive signal like:
		1) SIGHUP
			forces a file to reread it's config file
		10) SIGUSR1
	or you want to terminate a process with:
		9) SIGKILL
		15) SIGTERM
kill 56640
	kills process via PID
killall firefox
	kills all processes with the name firefox

first we can find the PID, then kill it:

pidof dd
kill -USR1 57329
	USR1 is short for SIGUSR1, or term signal 10

however, we can shorten these two command to one line with:

kill -USR1 $(pidof dd)

-

All Linux processes run with a suggested priority level handled by a system called Nice

range from 19 to 0 for unprivileged users
and range -1 to -20 for privileged users (such as root)

the most nice a process can be to the CPU is level 19
a process with a nice level of 19 will demand very few CPU resources so it will get very little CPU time
-20 is the least nice
0 is the default nice level, only privileged users can go below 0

dd if=/dev/zero of=/dev/null &
	this command writes zeros to /dev/null which just gets discarded
	am ampersand at the end of the line will cause dd to run asynchronously in the background,
	 and give your prompt back
	this process should take close to 100% of CPU core

in top, NI = nice level
PR = priority level,
	is generally the nice level +20

- setting a nice level is a suggestion to the linux kernel scheduler
- depending on the nice level, the scheduler tuning, and the circumstances, the priority level may change

renice -n 10 57439
	giving less CPU time to PID 57439
sudo renice -n -1 57433
	giving higher CPU time to PID 57433

if you know ahead of time how you want to influence the Linux schedular, you can start a process
 with a desired nice level using the nice command instead of renice

=====

Manage process jobs
-------------------

ctrl+c terminates active task in foreground
ctrl+z stops command and puts in background

watch executes a command every two seconds until terminated

watch ps -C dd --format pid,cmd,%cpu
	this will run the ps command every two seconds, only show the dd command processes, 
	 and output the process ID, the command name, and it's CPU usage

jobs
	shows currently running commands (and stopped commands)
	inside square brackets is the job spec number
	you can start this process back up either in the background or foreground

bg 1
	run job 1 (from job output) in the background
	if you only have one job you don't actually have to specify the job spec number

fg
	bring the process back to the foreground (in terminal)

dd if=/dev/zero of=/dev/null &
	you can start processes in the background by appending an ampersand to the command line

==========

Systemd processes
-----------------

system services
	- processes that are started by the operating system and sit in the background waiting to handle requests
	for example: web servers, file servers, mail servers, network servers

daemon = system service
Linux service naming conventions tack on the d for daemon: httpd, smbd, sshd, dhcpd

 - when a Linux system boots, the boot loader loads the kernel
 - the kernel in turn starts one super service (init)
 - and that service starts all other processes
 - most legacy Linux systems use System V Init (system 5 init) for this job

SysVinit Process Tree:

init	-	ModemManager
	-	NetworkManader
	-	abrtd
	-	atd
	-	auditd	-	sedispatch
			-	auditd
	-	gnome	-	ssh-agent
			-	gnome-keyring
	-	wpa_supplicant

SysVinit Runlevels:

 - each runlevel determined which services would be started
 - there would be run levels for:
	- command line only configurations
	- network configurations
	- troubleshooting situations
	- full graphical systems
 - you could switch between runlevels while the system was running

	Runlevel 3
		- acpid
		- atd
		- crond
		- iptables
	Runlevel 5
		- acpid
		- atd
		- crond
		- startx

SysVinit shortcomings:
 - the system had a few issues
 - it started services synchronously (one at a time)
 - and as such, a failed or slow service could hold up the others
 - each service was a shell script that run, services started slowly
 - didn't support dependencies, services ran independently of each other
 - service restarts disruptive

Linux service systems:
 - SysVinit
 - launchd
 - Upstart
 - systemd

Upstart:
 - designed by a former Ubuntu employee to solve some of SystemVinit's problems
 - starts processes asynchronously
 - monitors running processes
 - backward compatible with SysVinit
 - can be extended to interact with other event systems
 - used by Enterprise Linux 6 - all development has stopped

systemd:
 - Enterprise Linux 7 and 8 use systemd
 - it is becoming the standard across all types of Linux
 - suite of software replacing traditional systems
 - aims to unify Linux service configuration
 - includes init system
 - managed devices, logins, network connections, and logging
 - most major distributions today use systemd

==========

Get systemd service status
--------------------------

systemd unit types:
 - devices
 - mounted volumes
 - network sockets
 - system timers (similar to cronjobs)
 - targets (systemd equivalent to runlevels)

systemd Unit
 - systemd object that stores its configuration on disk as a unit file

systemctl
 - the systemctl command is what we use to manage systemd units

systemctl list-units
 - lists units the systemd currently has in memory
 - units that are running or were running previously
	services that are or were running previously

systemctl list-unit-files
 - lists installed unit files stored on disk
 - includes their auto-start state
 - when we desire a service to startup on boot, we enable it by changing the on disk configuration
	an autostart flag
 - another flag you may see called mask
	when a service is masked, it's impossible to start
	the list-unit-files subcommand lists these unit files as well

systemctl status
 - shows the status of a specified unit file, or the system status if one isn't specified
 - you can also pass a PID #, it will tell you which unit the process belongs to

systemctl list-unit-files -t service
	list only service unit (config) files
	q to quit

systemctl list-units -t service
	list running services
	including -a will also show enabled non-running services
		this would be services that are configured to start on boot but aren't currently running

systemctl list-units -at service --state running
	only show actively running services

systemctl cat rsyslog
	print service config file
	works for .service files, others you must specify extension

systemctl status rsyslog
	status of the service

==========

Manage systemd services
-----------------------

systemctl process options:
 - start
 - stop
 - restart
	these options do not survive a system reboot

systemctl persistence options
 - enable
 - disable
 - mask
 - unmask
	enabling & disabling configure whether a service starts at boot
	masking keeps a service from starting either manually or automatically
	these changes survive a reboot

sudo systemctl stop atd
systemctl list-units | grep atd
systemctl status atd
	check status
sudo systemctl restart atd

systemctl is-active atd
	prints if service is active
systemctl is-enabled atd
	prints if service is enabled

each of these subcommands will return a zero value to the $? variable
 if the service in question is active, failed, or enabled

echo $?
	// 0

sudo systemctl mask atd
	prevent atd from running either automatically or manually
sudo systemctl unmask atd

==========

make systemd services persistent
--------------------------------

sudo systemctl disable atd
sudo systemctl enable atd

==========

job scheduling
--------------

types of scheduled jobs:
 - one-time AT jobs
 - one-time batch jobs
 - recurring user jobs
 - recurring system jobs
 - systemd timers

one-time AT jobs
 - created by users and run once at a certain time
 - provided by the atd service

one-time batch jobs
 - created by users and run once at a certain time, but only if there are enough available system resources
 - provided by the atd service

recurring user jobs
 - created and managed by users and run on a repeating schedule
 - provided by the crond service

recurring system jobs
 - created by the system administrator and run by the operating system on a repeating schedule
 - provided by the crond service

systemd timers
 - created by the system administrator and run by the operating system on a repeating schedule
 - systemd timers - systemd equivalent to recurring cron jobs
 - advantages such as logging through systemd journal, and dependencies
 - however, systemd timers are more complicated to create and manage
 - provided by the systemd service

job access control
 - provides a mechanism to allow or deny users permission to create and manage jobs
 - can be configured for any of these job scheduling systems using a variety of different technologies

==========

one-time jobs using at and batch
--------------------------------

 - the AT service runs jobs at a certain time,
 or in the case of a batch job - when the CPU load average drops below 0.8

at <time>

AT time formats:
 - 4:25am
 - 16:45
 - midnight
 - noon
 - teatime
	4pm
 - now +2 hours
 - now +2 days
 - 4pm +3 days

AT specific date formats:
 - 3am tomorrow
 - January 15 2025
 - 011525
	month day year
 - 01/15/25
 - 01.15.25

AT combined time and date formats
 - at 12:30 011522
	[hh:mm MMDDYY]
 - at -t 202501151230.30
	[CCYYMMDDhhmm.ss]

at now +5min
	now it will ask for commands to run
atq
	show all AT jobs queued
	alternative command: at -l
at -c 1
	show contents of AT job 1, including the shell environment
atrm 1
	remove/cancel AT job 1

The difference between AT jobs and Batch jobs?
	Batch job runs only if the system load average is below 0.8

batch
	now it will ask for the commands to run
	ctrl+d when done entering commands
atq
	will also show batch jobs
	if you don't see any, it means the batch job ran

==========

About cronjobs
--------------

a cronjob is stored in a cron table or cron tab

Types of cronjobs
 - user cronjobs
	- specific to each user
	- managed by users
	- stored in /var/spool/cron/<user>
 - system cronjobs
	- systemwide
	- managed by root
	- run by the operating system
	- stored in /etc/cron.d

crontab format
	45	23	*		*		6		/home/user1/bin/backup.sh
	minute	hour	day (of month)	month (of year)	day of week	command to run
	[0-59]	[0-23]	[1-31]		[1-12]		[0-7]
							0 & 7=sunday
					[jan-dec]	[sun-sat]

with a system crontab, you can also specify user to run command as
	45	23	*		*		6	root	/home/user1/bin/backup.sh
								[user]

* = every minute
15,30,45 = on minutes 15,30,45
15-45 = a range, runs every minute from 15-45
*/10 = step values, run every 10th minute (skipping the nine in-between)
1-59/2 = run on every odd minute

-*-
A system cronjob with a time and date fields of 0 1 * * * would run the task every day at 1:00 AM. The five fields in the cron schedule expression represent:

Minute (0 - 59)
Hour (0 - 23)
Day of the month (1 - 31)
Month (1 - 12)
Day of the week (0 - 7) (where both 0 and 7 mean Sun, 1 = Mon, 2 = Tue, etc)
In your case, 0 1 * * * means the task will run when the minute is 0 and the hour is 1, which is 1:00 AM, and the * in the other fields means “any”, so it will run regardless of the day of the month, the month, or the day of the week. Therefore, the task will run every day at 1:00 AM.
-*-

Users can create cronjobs by using the crontab command.

online crontab generator - https://crontab-generator.org
man 5 crontab

==========

systemd timers
--------------

 - systemd allow you to define timer units
 - systemd timers are a powerful alternative to cron jobs

systemd timer unit types
 - real-time timers
	- activated on calendar events
	- act similar to cron jobs
	- start based on a date and time value
 - monotonic timers
	- activated after a time span relative to a starting point
		examples: five minutes after boot, 30 seconds after login

advantages of systemd timers (over cronjobs)
 - main benefits come from each job having its own service file
 - jobs can be started independently of their timers
 - jobs can run in their own environments
 - jobs can be attached to cgroups
	(container groups)
 - jobs can have dependencies (on other systemd units such as network)
 - jobs are logged in the systemd journal

advantages of cronjobs
 - easier to create
 - built-in support for emailing on job failure
	can be simulated with systemd timers however

 - systemd timers are named with a .timer extension and have a matching .service file
	backup.timer & backup.service, where the timer activates the service

systemctl list-timers
	list systemd timers
	lists when timer last ran and when it runs again,
	 as well as the timer unit name and the service unit that it activates

-

example of a service file:
backup.service

[Unit]
Description=System Backup

[Service]
Type=simple
ExecStart=/root/bin/systembackup.sh

[Install]
WantedBy=multi-user.target

-

example of a timer file:
backup.timer

[Unit]
Description=System backup every day at 2 AM

[Timer]
OnCalendar=*-*-* 02:00:00
Unit=backup.service

[Install]
WantedBy=multi-user.target

-

 - using OnCalendar we're creating a real-time timer
 - we have other keywords besides OnCalendar that will allow us to create monotonic timers

keywords for monotonic timers:
 - OnActiveSec
	relative to the moment the timer is activated
 - OnBootSec
	relative to when the machine booted up
 - OnStartupSec
	relative to when systemd was started
 - OnUnitActiveSec/OnUnitInactiveSec
	relative to when the unit the timer is activating was last activated/stopped
 - RandomizedDelaySec
	specify a random amount of time in which it should activate the service unit

-

monotonic timer:

[Unit]
Description=Run weekly and on boot

[Timer]
OnBootSec=15min
OnUnitActiveSec=1w

[Install]
WantedBy=timers.target

==========

Analyze system processes and optimize
-------------------------------------

 - /proc/cpuinfo
 - uptime
 - loadaverage

sysstat tools:
 - sar - collects and displays all system activities
 - sadf - generates report in CVS, XML, and others
 - iostat - generates CPU and IO statistics
 - mpstat - displays CPU statistics
 - pidstat - reports statistics on process ID

 - ksrar - not part of sysstat; Java GUI to display SAR reports

tuning the kernel:
 - sysctl - kernel-tuning tool
 - tuned - kernel-tuning service
	not mentioned on Linux+, but proc says it's a better way of managing custom kernel parameters

troubleshoot memory issues:
 - vmstat - processes, memory, paging, block IO, traps, disks, and CPU activity
 - free - shows free memory
 - /proc/meminfo - memory statistics

process states:
 - zombie
 - uninterruptible sleep
 - interruptible sleep
 - running

process priorities:
 - nice - sets initial process nice level
 - renice - changes process nice level
 - top - allows changing process nice level interactively

ending processes:
 - kill signals
 - kill - kills by PID
 - killall - kills by name
 - pkill - kills by pattern

process information:
 - ps - list processes
 - lsof - lists files open by running processes
 - pgrep - searches for processes

==========

troubleshoot applications and hardware
--------------------------------------

 - in any operating system with SELinux in enforcing mode, there may be context violations for applications
 - if you have a graphical interface you may be notified in there's been a violation
	and an application has been restricted
 - if you don't get a notification you can always run sealert, which will bring up the SELinux alert browser,
	the GUI tool that shows violations

 - sudo ausearch -m avc -ts today
	you can also search the auto logs by using ausearch
 - sudo ausearch -m avc -ts recent
	within the last 10 minutes
 - aureport
	produces summary reports of the audit log activity
 - /var/log/audit/audit.log
	you can elevate privileges and view the audit log directly

permission troubleshooting:
 - ls -la
 - getfacl
	view file access control list
look for
 - user permissions
 - group ownership
 - executable permissions
 - inheritance from an ACL

mount options:
 - mount
	the mounted volume may not allow executables, or in special cases,
	 may not allow SUID or SGIF programs to elevate their privileges
	 noexec, nosuid, noguid

check logs:
 - journalctl
	view system journal
 - /var/log/messages
	may change depending on the distribution
 - sudo strace <program> 2>&1 | grep <search>
	strace allows us to watch a program run to see what the issue may be
	we can look at which libraries it loads and which configuration files it uses
	strace outputs on both standard out and standard error, so you'll need to search the stderr to find problems

hardware troubleshooting:
 - lshw
	list all hardware
 - dmidecode
	see low level hardware that the BIOS sees