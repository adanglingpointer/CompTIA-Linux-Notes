

sudo dnf group install -y "Development tools"
sudo dnf install -y kernel-devel

sudo hostnamectl set-hostname whatever.localhost

-

sudo apt install -y build-essential linux-headers-$(uname -r)

==
Filesystem Hierarchy Standard
-----------------------------

/ (known as slash, root directory, or top level directory)
	/bin	= essential user command binaries (for use by all users)
		simple commands such as ls and cat
	/sbin	= utilities used for system administration
		command binaries essential for booting, restoring, recovering, and/or repairing the system,
		in addition to the binaries in /bin
	/boot	= bootloader files
		everything required for the boot process except configuration files not needed at boot time
		(config files for bootloaders not required at boot time must be placed in /etc) 
	/dev	= stores device files - an interface to the system's hardware through a device drive
		can also be input/output characters that act as if they were devices
	/etc	= contains static configuration files
		files should be stored in subdirectories

-

grep --help
help cd
man man-pages

-

mkdir -p parent/child

mkdir {dir1,dir2,dir3}
mkdir dir{1,2,3}
touch file{a,b,c}.txt

echo "A new line" >> textfile.txt

-

cat >> textfile.txt
This is a new line
	ctrl+d to save it

cp -a
	preserves all metadata
cp -u
	only copies if newer
cp -R
	recursive (folders)
cp -i
	interactive, ask before overwriting

rmdir
	only empty folders
rm -r
	remove directory with files
rm -ir
	interactive
rm file{c,d}.txt
	removes filec.txt and filed.txt

==

create links

symbolic link vs hard link

hard links:

ln whatyourelinkingto.txt whatyouwanttocallthelink.txt

Hard links create another name that points to the same data blocks that even have the same index or inode number.

advantages of hard links:
	takes up virtually no space
	doesn't break when target is deleted
	performance

disadvantages:
	can only hard link files and not directories
	can not link across file systems (different drives or partitions)
	transparent so difficult to identify
	must remove all inodes (index nodes) to delete hard links

ls -l
	usually files have 1 inode, so if it's 2 this is a hint it's a hard link

can compare two different files if they point to the same inode with stat
stat file.txt
stat filelink.txt

symbolic link:

ln -s file.txt filesymlink.txt

ls -l
	will show a symbolic link as
	lrwxrwxrwx. 1 user1 user1 8 Apr 17 03:37 filesymlink.txt -> file.txt
	-rw-rw-r--. 2 user1 user1 0 Apri 17 03:33 file.txt
the permissions on the real file are enforced (not symbolic link excessive permissions)

removing the original file will cause the symbolic link to break (show red in ls -l)
the inode on hardlink will remain but show as 1 with ls -l

advantages of symbolic links:
	can link across file systems
	can link to directories
	easy to identify

disadvantages of symbolic links:
	takes up space (small)
	breaks if target is deleted
	not seamless - commands may act differently when dealing with a symbolic link

pro tip:
ln -s archive/ dirlink
rm dirlink/
	this will delete the directory archive, not the link
	instead, remove the trailing /
	[didn't work for me on Debian]
rm dirlink

==========

I/O redirection

3 streams are created by a Linux shell when a command runs

STDIN	->	command	->	STDOUT
			->	STDERR

Function	Name	File Descriptor #
Input		STDIN	0
Output		STDOUT	1
ERROR OUTPUT	stderr	2

Command output methods:
Pipes - Takes output of a command and sends to the input of another
Redirects - Takes output of a command and sends to a file in the file system

Pipes
Command	->	STDOUT	->	Pipe	->	STDIN	->	Command

Redirects
Command	->	STDOUT/STDERR	->	&>	File

grep tcp /etc/services | less
This uses the grep command to search through the /etc/services file for the word tcp and sends the output to the less command, which displays it one page at a time. (press q to quit)

grep tcp /etc/services | awk '{print $1}' | sort | less
This uses the grep command to search through the /etc/services file for the word tcp and then sends the resulting lines to the awk command, which only prints the first column. Then sends the remaining output to the sort command which sorts in dictionary order and finally sends it to the less command to show one page at a time.

unnamed pipe is the default
named pipe - FIFO = First In First Out
	can pipe commands between terminals

Command	->	/home/mypipe	->	Command

a named pipe exists in the file system, that acts like a file on the disk

terminal one:
nkfifo named_pipe
echo "Hi" > named_pipe

terminal two:
cat named_pipe
	// Hi

==========

File redirects and tees
-----------------------

find > myfiles.txt
List all files in the current directory, saves STDOUT to myfiles.txt

find 2> myfiles-err.txt
Redirect STDERR to a file

find > myfiles.txt 2> myfiles-err.txt
Also works

find &> alloutput.txt
Redirect STDERR and STDOUT to a file

These all overwrite file.  We can instead append to end of file with >>

find >> myfiles.txt
find 2>> myfiles-err.txt
find &>> alloutput.txt

Redirect a file to STDIN:
mysql -u user1 p db_name < db.sql

Redirect to STDIN then output STDOUT and STDERR
mysql -u user1 p db_name < db.sql > out.txt 2> outerr.txt

tee splits output between a file and the sceen

Redirect STDOUT to a file and to the screen:
find | tee myfiles.txt

Append STDOUT to a file and to the screen:
find | tee -a myfiles.txt

Pipe only receives STDOUT by default, so we can combine STDOUT and STDERR into one stream.

Pipe STDERR and STDOUT to a command:
find 2>&1 | grep example.txt

2> redirects STDERR to &1 which is STDOUT.  This merges both STDERR and STDOUT and outputs on file descripter 1 (STDOUT). Then it pipes to grep to search it.

Newer versions of bash accept this alternative syntax:
find |& grep example.txt

This also does the same thing, redirecting STDERR and STDOUT to STDOUT.

-

Pipe only STDERR to a command:
find 2>&1 >/dev/null | grep example.txt

First it redirects STDERR on file descriptor 2 to STDOUT on file descriptor 1.  Then it redirects the original (old) STDOUT to /dev/null (oblivion!) so it doesn't get sent to the pipe.  Only STDERR gets send through the pipe to grep.

==

Find files using locate
-----------------------

locate uses a database created by the updatedb command.  it is fast but only finds files listed in database.  a system service updates once/day.

locate bzip2

print a number of how many results will be found:
locate -c bzip2

search for two items:
locate bzip2 man

search for items that contain both items/search terms:
locate -A bzip2 man

case insensitive searching:
locate -i high

wildcards with ls:
ls /etc/*.conf

regular expressions:
locate --regexp '^/usr.*pixmaps.*jpg$'

Find all paths that start with /usr, include the word pixmaps, and end with jpg.
^ anchors to the beginning of the line
.* matches any number of any characters
$ anchors to the end of the line

regular expresions for finding more than one:
locate --regex '^/usr.*{pixmaps|backgrounds}.*jpg'

this includes results for pixmaps or backgrounds

locate -S
List statistics of locate's database

==

find command
============

doesn't rely on database, so always up to date

sudo find / -name *bash*

sudo find / -not -iname *bash

-not = does not include
-iname = case insensitive

with find we can also use:
-f = file
-d = directory
-l = symbolic link
-c = character device
-b = block device

sudo find / -type f -name *bash*

can also search for more than one type at a time:

sudo find / -type f,d -name *bash*

find also works with -regex

Finding files by size:
find /usr -size +10M
	shows all files more 10MB

Signifier	Unit of Measurement
c		Bytes
k		Kilobytes
M		Megabytes
G		Gigabytes
b		512-byte blocks

We can also specify -empty for empty files:
find /usr -size -empty
(doesn't work for me)

Option		|File Type
-amin		|Last accessed (by minutes)
-atime		|Last accessed (by days)
-cmin		|Last changed (by min)
-ctime		|Last changed (by days)
-mmin		|Last modified (mins)
-mtime		|Last modified (days)

find / -atime 1
find / -atime -1
find / -atime +1

Find files that belong to a certain user or group:
sudo find / -user user1

We can also use find to search by permissions:
-readable
-writable
-executable

or numeric permissions:
-perm 644 [find by exact permissions]
-perm -644
-perm /644

or symbolic permissions:
-perm u=rw,g=r,o=r [find by exact permissions]
-perm -u=rw,g=r,o=r
-perm /u=rw,g=r,o=r

Find by exact permissions:
-perm 644
-perm u=rw,g=rw,o=r
 matches: -rw-rw-r--.

Find by all of the specified permissions:
-perm -664
 matches:	-rw-rw-r--
		-rw-rw-rx
will match all files with at least rw- rw- and r--, this would also match a file with 665 permissions, because that file would also have 664 in addition to execute.

Find by any of the specified permissions:
-perm /644 [was written with a + in the past, but this is no longer recommended]
will match files with any combition of rw-, r--, and r--
 matches	-rw-------.
		----r-----.
		-------r--.

Combining permissions can become complex.

find / -perm -a+r -perm /a+w \! -perm /a+x
This will find files that are readable by everyone [ -perm -a+r ],
at least one write bit is set [ -perm /a+w ],
and not executable by anyone [ \! -perm /a+x ]

Finding by SELinux security context using the -context option:
find / -type f -context '*ifconfig_exec_t*'
context is matches using pattern matching

Find can also perform a function with the files.

Action		Function
-print/-printf	Display output
-delete		Dlete matching files
-ls		List metadata of files
-prune		Omit matching files
-exec		Execute command for each

For example, executing an external command:
find / -size +1M -exec stat -c "%s %n" {} \;
This searches for files larger than 1MB [ -size +1M ],
and then runs the stat command on each file which outputs the size and name [ -exec stat -c "%s %n" ].
The curly braces are a placeholder for each search item's name which is passed to the stat command {}
\; tells find there are no more commands to run.

Other examples:

Find files with certain permissions and change them:
find / -type f -perm 644 -exec chmod 664 {}\;

Move .tar.gz files in /logs older than 7 days and move them into /backups:
find /logs -name "*.tar.gz" -mtime +7 -exec mv {} /backups \;

