13. System Security
===================

About pluggable authentication modules
--------------------------------------

 - Most services in Linjux use the same authentication system called PAM.
 - Pluggable Authentication Modules
 - Modular system, one authnetication method can be swapped out for another
 - Configurable and expandable
 - Redirectable authentication methods
 - PAM configuration files are text
	- Each service that uses PAM will have a service file in /etc/pam.d

 - Sun Microsystems proposed PAM in the mid 90s, and now it handles the authentication in most Unix-like operating systems including Linux.

cd /etc/pam.d
ls
cat su

 - Each line in PAM service file will have three or four columns, depending on options.

account		sufficient	pam_success_if.so	uid = 0			use_uid		quiet
Module Type	Control Flag	The PAM Module		Module Arguments

 - There are four different module types
	- Account - validates the account and performs non authentication based account maintenance
		It also restricts or grants access based on other factors
	- Auth - handles authentication of users and sets up credentials
		It handles challenge response requests and hardware tokens
	- Password - responsible for updating authentication methods and user passwords
	- Sessions - handles session specific tasks before and after login
		Such as mounting the user's home directory or providing an audit trail of logins

 - Control flags decide if authentication will continue through the authentication stack, or whether it will fail.
	- Required - If the item fails, then authentication fails, but only after remaining modules are processed.
	- Requisite - If the item fails, the authentication fails immediately.
	- Include - Allows external module stacks to be included.
		If an included module stack fails, then the rest of the module stack is skipped
	- Substack - Allows external module stacks to be included.
		If a module stack fails, then only the substack is skipped.
	- Optional - Not required for authentication.

 - If you want to know if a program has PAM support, you can double check this with the LDD command.
 - LDD prints the program's shared library dependencies

ldd /bin/su
	libpam.so.0 => /lib64/libpam.so.0

==========

Use login counters
------------------

To get a quick list of which PAM Modules are installed:
	cd /usr/lib64/security/
	ls

pam_access.so = who can authenticate and from where

 - You can turn off SSH root logins in the SSH configuration file.
 - This makes SSH more secure but creeates a problem if you do need SSH root access.
 - Using PAM Access, you can restrict root from logging in through SSH from every host but one.

pam_exec.so = allows you to call commands after authentication

 - For example you may want to rebuild an external password database every password change.

pam_limits.so = allows configuring resource limits for user sessions, including memory and CPU time

 - These limits also affect the root user.

PAM Login Counter
 - pam_tally
	In legacy systems
 - pam_tally2
	Options in PAM config
 - pam_faillock
	Replaces pam_tally2, it's easier to configure with a better code base
	Options in config file

 - pam_faillock maintains a list of failed authentication attempts per user during a specified interval and locks the account in case they exceed the configured threshold.

Faillock Module Options
 - preauth - call before auth
	Needs to be specified if the module is called before the mdoules that ask for credentials.
	When a user is going to be denied login based on previous attempts before they even get to enter
	 credentials.
 - authfail - call after fail
	Will log the failure to the appropriate tally file.
 - authsucc - call after success
	Will clear the record of the user's failures if they're not currently blocked.
	If this call is not provided then pam_faillock cannot determine between consecutive and non-consecutive
	 authentication failures.

man faillock
man faillock.conf

Faillock Module Arguments
 - audit
	Log the user of fail logins if they don't exist on the system.
 - silent
	Doesn't print messages to the user
 - no_log_info
	Doesn't log to the system logger
 - local_users_only
	Only tracks logins for local users that exist in the /etc/passwd file
 - nodelay
	Does not force a delay after failures
 - deny=
	Sets the number of consecutive failures before logging the user
 - fail_interval=
	The amount of time in which the failures need to occur to be considered consecutive
 - unlock_time=
	The amount of time in seconds before unlocking the account
	If it is set to 0, then the account has to be manually unlocked using the faillock command

Faillock Module Admin Arguments
 - even_deny_root
	Set the number of failures for the root account
 - root_unlock_time=
	The amount of time before the account is unlocked
 - admin_group=
	Treats users in an admin group such as wheel, the same as root

 - It's recommended to store these in /etc/security/faillock.conf, rather than cryptic PAM files

Example /etc/security/faillock.conf:

deny=4
unlock_time=1200
silent
audit

Example /etc/pam.d/login:

auth	[default=die]	pam_faillock.so authfail
auth	sufficient	pam_faillock.so authsucc

 - An easier way to configure PAM faillock is by using the authconfig command

authconfig --enablefaillock --faillockargs="deny=4 unlock_timeout=1200" --update

 - View failed logins
faillock --user <username>

 - Reset failed logins
faillock --user <username> --reset

==========

Change default password policies
--------------------------------

Password Strength
 - Linux administrators can tighten up password policies to force:
	- Password length
	- Unique characters
	- Unique character classes
	- Repeatable characters
	- Password similarity
		Check username and comment field of the /etc/passwd file

 - The password policy is controlled by the /etc/security/pwquality.conf

Password Restrictions

Option		Function
difok		Unique new characters required
		Setting this to 0 turns off all checks against the old password, unless they are identical
minlen		Minimum password length
		Credits will subtract from this number
		If you're using credits, you'll want to add one or more characters to your desired minimum
		Cannot be set lower than six
minclass	Unique character classes required
		You can require characters from all four classes by setting minclass to 4
maxrepeat	Maximum identical consecutive characters
maxclassrepeat	Maximum identical consecutive classes

 - All of these options can be turned off by setting them to 0.

Password Checks

Check		Description
decoscheck	Checks GECOS field for more than three characters
		Set to 1 to look for sequences of three characters or longer in the GECOS comment field that are
		 also in the new password
		It will find forward or reversed words
dictcheck	Checks for dictionary word
usercheck	Checks if password contains the username
badword		List of words that cannot be in a password

 - Linux has a credit system that affects the minimum allowed characters for a password
 - Credits allow for shortening of the password length, while maintaining password strength, by using characters from different classes, like lowercase, uppercase, digits, or other characters.
 - If your minimum password linked is nine and you configure credit for a lowercase letter, then Linux will allow an eight character password if it includes a lowercase letter.
 - If you have a credit for an uppercase letter, as well as a lowercase letter, then Linux will allow a seven character password.
 - If you have a credit for a digit, a lowercase letter, and an uppercase letter, it will accept a password that's six characters long.
 - For any of these credits, setting the credit to 0 disabled it. Setting to a positive number enables it.
 - For instance, if the credit is set to 1, then the password can be one character shorter.
 - Setting the credit to a negative number specifies the minimum number of special characters that is required.

 - Disable credit
dcredit = 0

 - Specify credit
dcredit = 1

 - Minimum characters required
dcredit = -3

Password Credit System

Credit		Description
dcredit=	Credit for digits
ucredit=	Credit for uppercase letters
lcredit=	Credit for lowercase letters
ocredit=	Credit for punctuation (other characters)

 - If you make changes to the system password policy in the pwquality.conf file, you may want to force users to change their password on the next login.

==========

Edit global user account details
--------------------------------

 - When we create a user without specifying account settings, the useradd command assumes a lot of things.
 - We can find these settings in the /etc/login.defs file

less /etc/login.defs

 - If we change anything in this file, it will only affect newly created users, not existing users.
 - In this file we can find the 'Password aging controls', defaults given to a user also seen in the /etc/shadow file.
 - PASS_MAX_DAYS, PASS_MIN_DAYS, PASS_MIN_LEN, and PASS_WARN_AGE
 - The minimum password length in /etc/security/pwquality.conf file overrides this, so it's not wortth changing it here.
 - Minimum user ID and group ID in older RHEL based systems started at 500.  Current systems start at 1000.
 - CREATE_HOME
	- On RHEL based systems it's customary to create a home directory for the user when the user is created.
	- This can be overridden with the `useradd -M` command

==========

Lock user accounts and change password aging
--------------------------------------------

 - For this exercise we'll create a username, brian, give him a password, and then lock the password.

sudo useradd brian
sudo passwd brian
sudo cat /etc/shadow
	verify brian has an encoded password
sudo passwd -l brian
	lock brian's password
sudo cat /etc/shadow
	verify again, the second field now starts with !! because it's locked

 - `password -l` only locks the password, and as such, a user could still login with SSH keys.
 - To fully lock the account, we'll use the chage command.

sudo chage -E 0 brian
	lock brian's account
sudo chage -l brian
	notice that brian's account expired Jan 1 of 1970

sudo chage -E -1 brian
	unlock account
sudo chage -l brian
	now we can see brian's account never expires

 - To see the status of the user's password, we can use the `passwd -S` command.

sudo passwd -S brian
	(Password locked.)
sudo passwd -u brian
	unlock brian
sudo passwd -S brian
	verify again
	(Password set, SHA512 crypt.)

 - Another option to keep users from logging in interactively is to change their shell.

cat /etc/passwd

 - Notice that all non-login accounts have their shell set to /sbin/nologin
 - This allows those accounts to function, i.e run applications and own files, but a user could not login to any of them.

sudo usermod -s /sbin/nologin brian
	Change brian's shell
cat /etc/passwd
	verify his default shell

 - To reverse the process,  just change it back to /bin/bash

==========

Force password resets
---------------------

sudo cat /etc/shadow
	remmeber or screenshot hash for user1

sudo passwd --expire user1

 - Logout and log back in as user1
 - Type in old password and you will get a reset message.  Type in old pass again before you set the new one.

sudo cat /etc/shadow
	password hash is different

 - You can also use the chage command to change password aging.

sudo chage -d 0 user1
	Change password aging

 - The chage command is very useful and powerful, and it's good to be comfortable with, but in this case the passwd command is probably easier to use.

==========

Configure Secure Shell
----------------------

Secure Shell (SSH) can provide us with:
 - Interactive login shell
 - Remote command execution
 - Secure network file copy
 - Network tunneling for traffic

 - A working Secure Shell System comproses of an SSH client on the local host and an SSH server on a remote host connected with an encrypted tunnel.

 - Linux, macOS, and Unix all come with SSH servers built in.
 - Third party SSH servers are available for Windows as well.
 - On Linux, the main SSH configuration files are stored in /etc/ssh

SSH Client
 - /etc/ssh/ssh_configt

SSH Server
 - /etc/ssh/sshd_config
	Main one
 - /etc/etc/sysconfig/sshd
	Minor one

 - You'll probably only need to edit the main one

Per-user client config
 - ~/.ssh/config

 - The .ssh directory doesn't exist until you try to connect to a server for the first time.
 - A per-user client config file allows us to store information about our remote servers to make administration easier.
 - For instance, if a remote server used port 1022 and we had a private/public key pair created for it, we would have a configuration file that looked like this:

Host server1
	User grant
	HostName server1.vmguesrs.com
	IdentityFile ~/.ssh/server1.key
	Port 1022

 - Without the config file, we'd have to type more to login remotely.
	ssh -p 1022 grant@server1.vmguests.com -i ~/.ssh/server1.key
	-i = identity file

 - Connection with per-user config
	ssh server1

==========

Explore PKI concepts
--------------------

Cryptography
 - Encode data for privacy
 - Encryption: turns plaintext into ciphertext via cryptographic algorithms
 - Decryption: turns ciphertext into plaintext
 - When the same key will lock and unlock the data, it's called a private key, or symmetric encryption.
	- This is great for securing data, but not good for transferring to another user, as you'd have to transfer
	 the key with it.
 - Private/public key pair (asymmetric)
	- A public key to encrypt data, and a private key to decrypt it

Encryption/Decryption
 - Hash - one-way mathimatical algorithms that turn plaintext into fixed length ciphertext
	- Because the algorithm only works one way, you can't unhash the text.
	- The resulting hashed ciphertext is called the message digest, hash value fingerprint, or signature.
	- Hashes can be used to compare data for tampering. If you hash the same data twice using the same
	 algorithm, you will get the same results, allowing you to check to see if the original has been altered.
	- The simplest hashed ciphertext is created with a non-salted hash. The ciphertext is created using only
	 the plaintext and the algorithm.
 - To strengthen the hash, a salt could be used, which is random data added to the input file before it's encoded.
 - Salted hash - message plus random data
 - The passwd file in Linux uses a salt

 - When you connect to a website, the web server will send you its public key.
 - Your browser will encrypt it's session key with it, and send it back.
 - Because the web server has access to the matching private key, it's able to decrypt a session key and notify the browser which then sets up an encrypted tunnel.
 - This system works well when all you care about is encryption. It doesn't validate that the web server is the legitimate owner of that domain, and not redirected traffic from a hacker.
 - The solution is signed certificated.
 - A certificate authority issues digital certificates that certifies that the ownership of a public key is the named subject of that certificate.
 - When you access secure websites, you are using signed certificates.

Public Key Infrastructure (PKI)
 - PKI is a system used to protect key integrity.
 - It is made up of a certificate authority, or CA, which verifies the user's identity and then issues a digital certificate.
 - The digital certificate is signed by the CA to provide validation.
 - The digital certificate provides identication proof, along with an embedded key which now belongs to the requester and can be used to encrypt data and sign it.
 - For development purposes, a user can create a certificate authority and create their own self-signed certificates. These should not be created for public use.

 - PKI can also be used to create digital signatures. Digital signatures work by providing that a digital message has not been modified from the time it was signed.
 - They do this by generating a hash of the message, encrypting it with a sender's private key, and then including it with the mssage.
 - The hash is unique to the mssage. The message is then digitally signed and sent to the recipient.
 - The recipient generates their own hash of the message and decrypts the sender's hash with the sender's public key. The recipient compares the hash they generated against the sender's decrypted hash. If they match, the message has not been tampered with, and the sender is authenticated.

==========

Configure key-based authentication for SSH
------------------------------------------

 - The first step to passwordless logins is to generate the SSH key pair using the ssh-keygen command on rhhost1.

ssh-keygen
	take the defaults when prompted
	since we didn't pass any options, it created RSA private and public keys
ls -l ~/.ssh
	we will find 'id_rsa' which is our private key,
	and 'id_rsa.pub' which is our public key

 - Now you need to copy the public key to your rhhost2 machine using it's hostname

ssh-copy-id rhhost2
	copy the public key across
ssh-add
	make sure that the key is added to the local SSH agent that managed the keys
	this isn't always necessary, but doesn't hurt if you run it

 - First, a local public key is copied across the network to the remote end and stored in the user's authorized_keys file.
 - Second, the fingerprint of the remote server is stored in the local known_hosts file.

cat ~/.ssh/known_hosts
	this file stores the IP address of the remote servers as well as their matching fingerprints.
	if the remote server ever changes its IP address, you will need to delete its line from this file
	 before connecting again.

 - On rhhost1:
	cat ~/.ssh/id_rsa.pub

 - On rhhost2
	cat ~/.ssh/authorized_keys

 - We can see that these files are exactly the same.
 - We can manually append any SSH public key to the authorized_keys file using a redirect, but it's best to let the ssh-copy-id command do it for you as SSH can be very picky about file permissions and syntax.

==========

Tunnel data with SSH
--------------------

 - A lot of protocols on Linux are not encrypted:
	- X11 and VNC for remote graphical desktops
	- rsync for remote file copies
	- some configuration management systems
 - All of these can utilize SSH for tunneling

 - Normally when you use SSH to connect to another system you get a shell prompt.
 - You can also execute command on the remote host without logging into an interactive session by providing them as arguments on the command line
	ssh user1@dbhost1 "runbackup.sh"
 - You can also send data through the SSH tunnel by piping it to the SSH command and running a program on the remote end to read from standard-in and act on the data in some manner
	cat /etc/hosts | shh user1@dbhost1 "cat - > /ome/user1/hosts"

SSH Tunneling Support (natively)
 - Local port forwarding
 - Remote port forwarding
 - Dynamic port forwarding

 - When port forwarding is used, SSH creates a separate tunnel inside of an existing SSH connection.
 - Network traffic is then forwarded from one port to another on a different host.

Local Port Forwarding
 - In this example, SSH would create an encrypted tunnel to dbhost1 and login as user1.
 - SSH will then listen on a local port, in this case 1080.
 - When a connection is made to this local port, the data is forwarded across the tunnel to the remote network, either to the connected host itself using the localhost address or another host on the remote network and to the specified port.

ssh -L 1080:127.0.0.1:80 user1@dbhost1
ssh -L 1080:192.168.2.100:80 user1@dbhost1

 - This will take all of the local traffic to the local client's port 1080 and forward it through the tunnel to port 80 on the remote host where it would presumably connect to a web server.

