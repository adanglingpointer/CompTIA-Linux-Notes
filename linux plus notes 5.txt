Chapter 11. File Security
=========================

What is a file?
---------------

 - In Linux, everything is a file

Regular file
 - Binary or text, saved on a storage device, and can be read and written to.
 - Metadata
	- Ownership
	- Access control
	- File size
	- Creation date
	- Metadata is data that describes other data, the contents of the file

Directory file
 - Lists files
 - Associates data with files names
 - The directory associates data blocks with file names

Device drivers - drivers that connect applications to physical hardware
 - In Linux, everything is a file including printers.
 - The printer device is a file.
 - You can save data to it using the same tools that we use to save data to a regular file.
 - When that data is saved to a printer file, it's sent to the printer.
 - A printer is a kind of Character Device File

Block Device File
 - A physical device that appears as a file
 - A storage device such as a solid state disk

Character Device File
 - Unique because they can be virtual, in that they might not represent a real physical device.
 - We have a character device file called Zero that when read gives us an endless supply of zeros.
	/dev/zero = 0000000000000...
	/dev/null = text that we don't want to keep
		swallows everything that is written to it
		this is useful when you don't want the output of a command to show on the screen
 - Our screen is a character device file as well.

Network Socket File
 - Network sockets are also files.
 - Writing data to a network socket can send it across the network.
 - They may also be used to send data between programs on a local computer.

Virtual Files
 - Files that don't really exist anywhere and have no size, but you can still read and write to them
	/proc/cpuinfo
		Shows info about the CPU, has data in it, but has a size of zero bytes because the OS creates
		 the data instantly when it's being read

 - Even the output of an application is considered a file that has not been saved yet

Pipe File
 - A physical tube, or pipe, from one application to another.

What is the advantage of all of this, considering other operating systems don't operate this way?
 - The idea of everything being a file allows us to view important system information and write data to physical devices with simple tools.
 - It allows us to read block devices and the output of commands using simple text viewers.
 - It allows us to have one command communication with another without any special software, which allows us to combine multiple simple commands to solve complex problem.
 - The concept of everything being a file sets Linux apart from other operating systems and proves to be very powerful.

==========

Get information about files
---------------------------

Metadata
 - Data that describes other data is called metadata
 - File name
 - File size
 - Permissions
 - Ownership
 - Access time
 - And more

 - The quickest way to get information about a file is by doing a long list of the file

ls -l /etc/passwd

Long List of a File

-rw-r--r--. 1 root root 2750 Feb 9 23:07 /etc/passwd

-		rw-				r--				r--.
File type	User owner's permissions	Group owner's permissions	Permissions for other	

1				root 		root 		2750
Number of inodes the file uses	User owner	Group owner	Size of the file in bytes

Feb 9 23:07			/etc/passwd
Last modified date and time	Name of the file

 - First column is the file type
	- means regular data file

Linux File Types
Character	Type
-		Regular File
b		Block Device
c		Character Device
d		Directory
l		Symbolic Link
n		Network File
p		FIFO (pipe)
s		Socket

 - The next three characters are the user owner's permissions
	rw-

r = read
w = write
x = execute

 - Inodes, or index nodes, stores the metadata about the file, as well as a pointer to the location of the data blocks on the disk.
 - The inode of a file does not contain the name.  The file's name is not stores in the file's inode.  We need a directory inode for that.
 - Directory data is stored in directory inodes.

 - In Linux, a file name is only hidden if the first character of its name is a dot.

ls -la
	List hidden files (l = long list, a = all)

file /etc/passwd
	List the tile type
	ie. ASCII text
	The file command looks at the bits of the file to determine which type it is.

stat /etc/passwd
	Another command to show file info

Stat of a file
File: /etc/passwd
Size: 2750	Blocks: 8	IO Blocks: 4096		regular file
Device: fd00h/64768d	Inode: 2101122	Links: 1
	Size in bytes
	Number of file system blocks
	Size of the IO block = size in bytes of every block
	Type of file
	Device number
	Inode number
	Number of hard links
	Permissions
	ID number of the user owner
	ID number of the group owner
	SELinux security context

 - Each drive uses the same number for inodes, so two files on two drives can have the same inode number.
 - However, the device number in combination with the inode number makes a unique address.
 - Stat also shows (last) access, modify, and change dates.
	modify = content modified
	change = last time and attribute or content was modified
		ie. metadata would update if we changed ownership or permissions, but the file data is not changed
 - Birth = creation file.  This last item came from UNIX, and is not supported on Linux.

==========

Extended Attributes
 - Require support by the OS
 - Extensions to file
 - Stored with files on disk
 - Three major types of extended attributes
	- Extended system attributes
	- Extended security attributes
	- Extended user attributes

Extended System Attributed
 - Store file access control lists (ACLs)
	- Permissions for multiple users
	- Permissions for multiple groups
	- Inheritance
	- Backup and restore permissions

Extended Security Attributes
 - SELinux mandatory access control system
	- Layered over discretionary access control
	- System-wide rules restricting all users
 - SELinux modes
	- Multilevel security
		mimics a government security levels, ie. level 3 security clearance
	- Role-based access control
	- Type enforcement
		What Enterprise Linux mostly uses to enforce security policy
		All files, processes, and users are tagged with a type

Extended User Attributes
 - Store additional flags
	- Called extended attributes
	- Append only
	- Compress
	- Immutable
		The file can not be modified, deleted or renamed, and no data can be written to the file
		This is true even for the root user
		However, the root user can remove the immutable flag
	- Backup
		When the backup flag is set and the file is deleted, the data is backed up so we can un-delete
		 it later.

 - Not all file systems or operating systems support all extended attributes.

==========

Get extended attributes
-----------------------

touch aclfile.txt

ls -l aclfile.txt
	Take a look at the permissions on this file using a long list

setfacl -m user:root:rwx aclfile.txt
	Set an ACL on the file
	-m = modify

getfacl -t aclfile.txt
	Shows standard Linux permissions and ownership, as well as the additional ACL for the root user

 - The ls command cannot display the access control list, however, there is now a plus symbol where there used to be a dot.
	From:	-rw-rwxr--.
	To:	-rw-rwxr--+
 - This clue tells you that there's an ACL set and that you need to use the getfacl command to see it.

ls -Z aclfile.txt
	Show SELinux security context
	unconfined_u:object r:user_home_t:s0 aclfile.txt
		User is unconfined
		The role is object
		The type for tpye enforcement is user_home_t
		The security level is 0
			We didn't add this context, it was auotmatic based on rules in the SELinux policy database

Extended user attributes:

sudo chattr +i aclfile.txt
	Add an extended attribute to file (immutable)
lsattr aclfile.txt
	Viewing extended attribute
	----i---------- aclfile.txt
lsattr -l aclfile.txt
	Verbose
	aclfile.txt Immutable

Getting Extended Attributes
Task				Command
Verify existence of ACL		ls -l
Show ACL information		getfacl
Show SELinux security context	-Z option
Show extended attributes	lsattr

==========

Linux permissions overview
--------------------------

 - The standard Linux permission system came from Unix and was created 40 years ago.

Features of Standard Permissions
 - Users belong to multiple groups
	- Groups can NOT contain other groups
 - Files belong to one user
 - Files belong to one group
 - Permissions can be set for user, group, or other
 - Files: users can read, write, and execute
 - Directories: users list, create files, and traverse
 - Support privilege escalation
 - Support group owner inheritance
	- Files and directories can inherit the parent directory's group owner
 - Support default file permissions

Shortfalls of Ownership
 - Files can only belong to one user
 - Files can only belong to one group
 - Directories can only belong to one user
 - Directories can only belong to one group
 - Inheritance only for group owner
	- A child file or directory can inherit the parent directory's group owner but not its permissions
 - Permissions set for "other" are not concise
 - Backing up permissions difficult
 - No temporary permissions
 - Access Control Lists remedy most of these issues

==========

File and directory modes
------------------------

Permission Modes
 - Read
	Read permissions for files - read contents of a file
	Read permissions for directories - read the metadata of files in the directory
 - Write
	Write permissions for files - Write or modify content of a file
	Write permissions for directories - Create new files in a directory
 - Execute
	Execute permissions for files - Load files into memory and run on the CPU
	Execute permissions for directories - Enter or traverse the directory

==========

File ownership
--------------

 - The command that we use to change the ownership of a file is chown.
 - In order to change the ownership of a file, you need to be root or elevated privileges with sudo.
 - The users and groups have to exist before we can change ownership to them.
 - You can get a list of existing users by viewing the /etc/passwd file.
 - You can get a list of existing groups by viewing the /etc/group file.

chown Syntax
	chown [options] <user>:<group> <file>

chown user1 file.txt
	Setting the User Owner

chown :accounting file.txt
	Setting the Group Owner

chown User1:accounting file.txt
	Setting User and Group Owners

Exercise with ownership:
mkdir ownexercise
cd ownexercise/
pwd
touch file.txt
sudo useradd testuser
cat /etc/passwd
sudo groupadd testgroup
cat /etc/group
sudo chown testuser:testgroup file.txt
ls -l

chown -R <user>:<group> /home/<user>
	Ensure that all files in a user's home directory are owned by the user and their primary group.
	-R = recursively

==========

Permissions using the numeric method
------------------------------------

Permission Methods
 - Numeric method
 - Symbolic method

Numeric Mode
Mode	Value
Read	4
Write	2
Execute	1

 - The command we use to set permissions is chmod (change mode).
 - Initial permissions are assigned to new files based on the value of the umask.

chmod Syntax
	chmod [options] <permissions> <filename>
	chmod 750 file.txt

Exercise with permissions:
mkdir permexercise
cd permexercise/
touch file.txt
ls -l
chmod 750 file.txt
	User Owner = read/write/execute
	Group Owner = read/execute
	Other = no permissions
ls -l

==========

Permissions using the symbolic method
-------------------------------------

chmod u=rwx,g=rx,o= file.txt
	user = read/write/execute
	group = read/execute
	other = none
 - With symbolic method, we can also add permissions by changing the equal sign to a plus, or subtract permissions with a minus.

chmod u+rwx file.txt
	Add rwx to a user

chmod o-x file.txt
	Take execute permissions away from other

 - You can also group the positions:
	Take away execute for user, group, and other:
	chmod ugo-x file.txt
	Alternatively, we can use a for all
	chmod a-x file.txt

sudo useradd bob
sudo chmod -R a-x /home/bob
	Remove all execute permissions for every file in /home/bob