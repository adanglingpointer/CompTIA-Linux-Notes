Chapter 11. File Security
=========================

What is a file?
---------------

 - In Linux, everything is a file

Regular file
 - Binary or text, saved on a storage device, and can be read and written to.
 - Metadata
	- Ownership
	- Access control
	- File size
	- Creation date
	- Metadata is data that describes other data, the contents of the file

Directory file
 - Lists files
 - Associates data with files names
 - The directory associates data blocks with file names

Device drivers - drivers that connect applications to physical hardware
 - In Linux, everything is a file including printers.
 - The printer device is a file.
 - You can save data to it using the same tools that we use to save data to a regular file.
 - When that data is saved to a printer file, it's sent to the printer.
 - A printer is a kind of Character Device File

Block Device File
 - A physical device that appears as a file
 - A storage device such as a solid state disk

Character Device File
 - Unique because they can be virtual, in that they might not represent a real physical device.
 - We have a character device file called Zero that when read gives us an endless supply of zeros.
	/dev/zero = 0000000000000...
	/dev/null = text that we don't want to keep
		swallows everything that is written to it
		this is useful when you don't want the output of a command to show on the screen
 - Our screen is a character device file as well.

Network Socket File
 - Network sockets are also files.
 - Writing data to a network socket can send it across the network.
 - They may also be used to send data between programs on a local computer.

Virtual Files
 - Files that don't really exist anywhere and have no size, but you can still read and write to them
	/proc/cpuinfo
		Shows info about the CPU, has data in it, but has a size of zero bytes because the OS creates
		 the data instantly when it's being read

 - Even the output of an application is considered a file that has not been saved yet

Pipe File
 - A physical tube, or pipe, from one application to another.

What is the advantage of all of this, considering other operating systems don't operate this way?
 - The idea of everything being a file allows us to view important system information and write data to physical devices with simple tools.
 - It allows us to read block devices and the output of commands using simple text viewers.
 - It allows us to have one command communication with another without any special software, which allows us to combine multiple simple commands to solve complex problem.
 - The concept of everything being a file sets Linux apart from other operating systems and proves to be very powerful.

==========

Get information about files
---------------------------

Metadata
 - Data that describes other data is called metadata
 - File name
 - File size
 - Permissions
 - Ownership
 - Access time
 - And more

 - The quickest way to get information about a file is by doing a long list of the file

ls -l /etc/passwd

Long List of a File

-rw-r--r--. 1 root root 2750 Feb 9 23:07 /etc/passwd

-		rw-				r--				r--.
File type	User owner's permissions	Group owner's permissions	Permissions for other	

1				root 		root 		2750
Number of inodes the file uses	User owner	Group owner	Size of the file in bytes

Feb 9 23:07			/etc/passwd
Last modified date and time	Name of the file

 - First column is the file type
	- means regular data file

Linux File Types
Character	Type
-		Regular File
b		Block Device
c		Character Device
d		Directory
l		Symbolic Link
n		Network File
p		FIFO (pipe)
s		Socket

 - The next three characters are the user owner's permissions
	rw-

r = read
w = write
x = execute

 - Inodes, or index nodes, stores the metadata about the file, as well as a pointer to the location of the data blocks on the disk.
 - The inode of a file does not contain the name.  The file's name is not stores in the file's inode.  We need a directory inode for that.
 - Directory data is stored in directory inodes.

 - In Linux, a file name is only hidden if the first character of its name is a dot.

ls -la
	List hidden files (l = long list, a = all)

file /etc/passwd
	List the tile type
	ie. ASCII text
	The file command looks at the bits of the file to determine which type it is.

stat /etc/passwd
	Another command to show file info

Stat of a file
File: /etc/passwd
Size: 2750	Blocks: 8	IO Blocks: 4096		regular file
Device: fd00h/64768d	Inode: 2101122	Links: 1
	Size in bytes
	Number of file system blocks
	Size of the IO block = size in bytes of every block
	Type of file
	Device number
	Inode number
	Number of hard links
	Permissions
	ID number of the user owner
	ID number of the group owner
	SELinux security context

 - Each drive uses the same number for inodes, so two files on two drives can have the same inode number.
 - However, the device number in combination with the inode number makes a unique address.
 - Stat also shows (last) access, modify, and change dates.
	modify = content modified
	change = last time and attribute or content was modified
		ie. metadata would update if we changed ownership or permissions, but the file data is not changed
 - Birth = creation file.  This last item came from UNIX, and is not supported on Linux.

==========

Extended Attributes
 - Require support by the OS
 - Extensions to file
 - Stored with files on disk
 - Three major types of extended attributes
	- Extended system attributes
	- Extended security attributes
	- Extended user attributes

Extended System Attributed
 - Store file access control lists (ACLs)
	- Permissions for multiple users
	- Permissions for multiple groups
	- Inheritance
	- Backup and restore permissions

Extended Security Attributes
 - SELinux mandatory access control system
	- Layered over discretionary access control
	- System-wide rules restricting all users
 - SELinux modes
	- Multilevel security
		mimics a government security levels, ie. level 3 security clearance
	- Role-based access control
	- Type enforcement
		What Enterprise Linux mostly uses to enforce security policy
		All files, processes, and users are tagged with a type

Extended User Attributes
 - Store additional flags
	- Called extended attributes
	- Append only
	- Compress
	- Immutable
		The file can not be modified, deleted or renamed, and no data can be written to the file
		This is true even for the root user
		However, the root user can remove the immutable flag
	- Backup
		When the backup flag is set and the file is deleted, the data is backed up so we can un-delete
		 it later.

 - Not all file systems or operating systems support all extended attributes.

==========

Get extended attributes
-----------------------

touch aclfile.txt

ls -l aclfile.txt
	Take a look at the permissions on this file using a long list

setfacl -m user:root:rwx aclfile.txt
	Set an ACL on the file
	-m = modify

getfacl -t aclfile.txt
	Shows standard Linux permissions and ownership, as well as the additional ACL for the root user

 - The ls command cannot display the access control list, however, there is now a plus symbol where there used to be a dot.
	From:	-rw-rwxr--.
	To:	-rw-rwxr--+
 - This clue tells you that there's an ACL set and that you need to use the getfacl command to see it.

ls -Z aclfile.txt
	Show SELinux security context
	unconfined_u:object r:user_home_t:s0 aclfile.txt
		User is unconfined
		The role is object
		The type for tpye enforcement is user_home_t
		The security level is 0
			We didn't add this context, it was auotmatic based on rules in the SELinux policy database

Extended user attributes:

sudo chattr +i aclfile.txt
	Add an extended attribute to file (immutable)
lsattr aclfile.txt
	Viewing extended attribute
	----i---------- aclfile.txt
lsattr -l aclfile.txt
	Verbose
	aclfile.txt Immutable

Getting Extended Attributes
Task				Command
Verify existence of ACL		ls -l
Show ACL information		getfacl
Show SELinux security context	-Z option
Show extended attributes	lsattr

==========

Linux permissions overview
--------------------------

 - The standard Linux permission system came from Unix and was created 40 years ago.

Features of Standard Permissions
 - Users belong to multiple groups
	- Groups can NOT contain other groups
 - Files belong to one user
 - Files belong to one group
 - Permissions can be set for user, group, or other
 - Files: users can read, write, and execute
 - Directories: users list, create files, and traverse
 - Support privilege escalation
 - Support group owner inheritance
	- Files and directories can inherit the parent directory's group owner
 - Support default file permissions

Shortfalls of Ownership
 - Files can only belong to one user
 - Files can only belong to one group
 - Directories can only belong to one user
 - Directories can only belong to one group
 - Inheritance only for group owner
	- A child file or directory can inherit the parent directory's group owner but not its permissions
 - Permissions set for "other" are not concise
 - Backing up permissions difficult
 - No temporary permissions
 - Access Control Lists remedy most of these issues

==========

File and directory modes
------------------------

Permission Modes
 - Read
	Read permissions for files - read contents of a file
	Read permissions for directories - read the metadata of files in the directory
 - Write
	Write permissions for files - Write or modify content of a file
	Write permissions for directories - Create new files in a directory
 - Execute
	Execute permissions for files - Load files into memory and run on the CPU
	Execute permissions for directories - Enter or traverse the directory

==========

File ownership
--------------

 - The command that we use to change the ownership of a file is chown.
 - In order to change the ownership of a file, you need to be root or elevated privileges with sudo.
 - The users and groups have to exist before we can change ownership to them.
 - You can get a list of existing users by viewing the /etc/passwd file.
 - You can get a list of existing groups by viewing the /etc/group file.

chown Syntax
	chown [options] <user>:<group> <file>

chown user1 file.txt
	Setting the User Owner

chown :accounting file.txt
	Setting the Group Owner

chown User1:accounting file.txt
	Setting User and Group Owners

Exercise with ownership:
mkdir ownexercise
cd ownexercise/
pwd
touch file.txt
sudo useradd testuser
cat /etc/passwd
sudo groupadd testgroup
cat /etc/group
sudo chown testuser:testgroup file.txt
ls -l

chown -R <user>:<group> /home/<user>
	Ensure that all files in a user's home directory are owned by the user and their primary group.
	-R = recursively

==========

Permissions using the numeric method
------------------------------------

Permission Methods
 - Numeric method
 - Symbolic method

Numeric Mode
Mode	Value
Read	4
Write	2
Execute	1

 - The command we use to set permissions is chmod (change mode).
 - Initial permissions are assigned to new files based on the value of the umask.

chmod Syntax
	chmod [options] <permissions> <filename>
	chmod 750 file.txt

Exercise with permissions:
mkdir permexercise
cd permexercise/
touch file.txt
ls -l
chmod 750 file.txt
	User Owner = read/write/execute
	Group Owner = read/execute
	Other = no permissions
ls -l

==========

Permissions using the symbolic method
-------------------------------------

chmod u=rwx,g=rx,o= file.txt
	user = read/write/execute
	group = read/execute
	other = none
 - With symbolic method, we can also add permissions by changing the equal sign to a plus, or subtract permissions with a minus.

chmod u+rwx file.txt
	Add rwx to a user

chmod o-x file.txt
	Take execute permissions away from other

 - You can also group the positions:
	Take away execute for user, group, and other:
	chmod ugo-x file.txt
	Alternatively, we can use a for all
	chmod a-x file.txt

sudo useradd bob
sudo chmod -R a-x /home/bob
	Remove all execute permissions for every file in /home/bob

==========

Initial permissions using umask
-------------------------------

 - When files are created, initial permissions are applied auotmatically.
 - These permissions are calculated based on a bit mask called umask

umask
	View umask
		0022
	Can be either three characters or four, can leave leading zero on or off for standard permissions
	umask isn't the same format as numeric permissions such as 754
umask -S
	View umask in symbolic notation
		u=rwx,g=rx,o=rx

Initial Directory Permissions
	777 = Max Initial Directory Mode
 777 Max Initial Directory Mode
-022 umask
----
 755 Initial Directory Mode
	rwxr-xr-x

Initial Directory Permissions
	666 = Max Initial File Mode
	For security reasons we don't allow execute permissions on files by default
	This keeps files from being automatically executable after being copies from one place to another,
	 including files downloaded from the internet
 666 Max Initial File Mode
-022 umask
----
 644 Initial File Mode
	rw-r--r--

 - We can temporary change our umask by using the umask command.

umask 0002
	rwxrwxr-x default permissions for directories, rw-rw-r-- for files

 - This only works for our current login session.
 - If a user wants to change their umask, they can add it tot heir bash startup file using an editor.

vi ~/.bashrc
	add the line:
	umask 0002

 - If an administrator wants to change the system-wide umask, they can add it to a file in /etc/profile.d

sudo vi /etc/profile.d/umask.sh

if [ "$UID" -ge 1000 ] ;
	umask 0002
fi

-ge for greater than or equal to

==========

Special file bits: SUID and SGID
--------------------------------

 - There are additional special bits for privilege escalation on executable files.

Special Bits on Files
 - Set User ID (SUID)
	- Run as user owner of the file
 - Set Group ID (SGID)
	- Run as group owner of the file
 - Sticky
	- Historically in Unix, if you set the Sticky bit on a program, it would remain in swap making it execute
	 faster the next time it is run.
	- Some versions of Unix and BSD still maintain this functionality, but it has never existed in Linux.
	- Linux caches all executables for faster execution anyway, so there's little need for a Sticky bit.

ls -l /usr/bin/su
	-rwsr-xr-x. 1 root root 50448 Apr 24 05:39 /usr/bin/su
	The file /usr/bin/su is bright red

 - The permissions in this case for the User Owner are rws.
 - The s in the User Owner's execute position means that we have SUID bit set.
 - If the s is lowercase then the underlying execute bit is also set.
 - If the S is uppercase then the execute permissins are not set.

 - When the S exists in the Group Owner permissions, then the SGID is set.
	-rwxr-sr-x.
 - Lowercase s = execute permissions are set
 - Uppercase S = execute permissions are not set

 - When the SUID bit is set, and if regular users such as user1 executes the command, their privileges get elevated to that of the User Owner's.
 - In our example, user1 would be executing the su command as root.
	-rwsr-xr-x. 1 root root 50448 Apr 24 05:39 /usr/bin/su
 - This means this command would have all of the power of the root user.

Special Bit Values

Mode	Value
SUID	4
SGID	2
Sticky	1

-rwsr-xr-x. 1 root root 50448 Apr 24 05:39 /usr/bin/su
	SUID is set so 4 + 0 + 0 = 4
	Our original permissions are 755
	Add the 4 in front for total permissions in numeric mode with SUID set are 4755

sudo chmod 4755 /usr/bin/su
	Set SUID permissions
sudo chmod u+s /usr/bin/su
	Set SUID permissions in symbolic mode

 - The SGID bit is very similar to SUID.
 - When we have SGID set, the s resides in the execute position of the Group Owner's permissions.
 - When a regular user, such as user1 executes a command with SGID set, it runs with the privileges of the Group Owner of the file, in this example the screen group:
	-rwxr-sr-x. 1 root screen 0 Jan 5 13:26 /usr/bin/screen
 2 4 4 4 SGID value is the leading 2
 0 2 0 0
+0 1 1 1
--------
 2 7 5 5

sudo chmod 2755 /usr/bin/screen
	Set SGID permissions
sudo chmod g+s /usr/bin/screen
	Set SGID permissions in symbolic mode

 - Because these commands allow privilege escalation without prompting for a password, it may be advantageous to know where in the file system they are for security reasons.
 - We can use the find command to locate SUID and SGID files.

sudo find / -perm -4000
	Find all files with the SUID bit set

sudo find / -perm -2000
	Find all files with the SGID bit set

==========

Special directory bits: SGID and sticky bit
-------------------------------------------

Special Bits on Directories
 - Set user ID (SUID)
	- No effect on directories
 - Set group ID (SGID)
	- Provides group inheritance for files and directories created inside the directory
 - Sticky
	- Only owners can delete their own files

cd /home
pwd
sudo mkdir accounting
ls -l
	Since we created the directory using sudo it's owned by the root user and the root group
sudo groupadd accounting
sudo chown :accounting accounting/
sudo chmod 2770 accounting
	Add the SGID bit as well as right permissions for the Group Owner
ls -l
	drwxrws---.	2 root	accounting	6 Oct	5 14:09 accounting

SGID Bit on Directories

	drwxrws---.	2 root	accounting	6 Oct	5 14:09 accounting

 - SGID bits on directories represent the only inheritance in standard Linux permissions and ownership.
 - All files and directories created inside of your accounting directory will inherit the Group Owner, accounting.
 - If user1 creates a file in the accounting directory, it will be owned by user1 and the accounting group.
	-rwxr-sr-x.	1 user1	accounting	0 Jan	5 13:36 /home/accounting/file.txt

 - This allows us to create a directory for group collaboration.
 - For our setup, all users creating files in this directory would need to belong to the accounting group in order for them to have right access.

sudo useradd -G accounting ted
	-G = supplemental group
sudo passwd ted
cat /etc/group
	accounting group with ted in it at the bottom
su - ted
cd /home/accounting/
pwd
touch file.txt
ls -l
	-rw-rw-r--. 1 ted accounting 0 Oct 5 14:14 file.txt
exit

