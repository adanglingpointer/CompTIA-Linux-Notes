Chapter 11. File Security
=========================

What is a file?
---------------

 - In Linux, everything is a file

Regular file
 - Binary or text, saved on a storage device, and can be read and written to.
 - Metadata
	- Ownership
	- Access control
	- File size
	- Creation date
	- Metadata is data that describes other data, the contents of the file

Directory file
 - Lists files
 - Associates data with files names
 - The directory associates data blocks with file names

Device drivers - drivers that connect applications to physical hardware
 - In Linux, everything is a file including printers.
 - The printer device is a file.
 - You can save data to it using the same tools that we use to save data to a regular file.
 - When that data is saved to a printer file, it's sent to the printer.
 - A printer is a kind of Character Device File

Block Device File
 - A physical device that appears as a file
 - A storage device such as a solid state disk

Character Device File
 - Unique because they can be virtual, in that they might not represent a real physical device.
 - We have a character device file called Zero that when read gives us an endless supply of zeros.
	/dev/zero = 0000000000000...
	/dev/null = text that we don't want to keep
		swallows everything that is written to it
		this is useful when you don't want the output of a command to show on the screen
 - Our screen is a character device file as well.

Network Socket File
 - Network sockets are also files.
 - Writing data to a network socket can send it across the network.
 - They may also be used to send data between programs on a local computer.

Virtual Files
 - Files that don't really exist anywhere and have no size, but you can still read and write to them
	/proc/cpuinfo
		Shows info about the CPU, has data in it, but has a size of zero bytes because the OS creates
		 the data instantly when it's being read

 - Even the output of an application is considered a file that has not been saved yet

Pipe File
 - A physical tube, or pipe, from one application to another.

What is the advantage of all of this, considering other operating systems don't operate this way?
 - The idea of everything being a file allows us to view important system information and write data to physical devices with simple tools.
 - It allows us to read block devices and the output of commands using simple text viewers.
 - It allows us to have one command communication with another without any special software, which allows us to combine multiple simple commands to solve complex problem.
 - The concept of everything being a file sets Linux apart from other operating systems and proves to be very powerful.

==========

Get information about files
---------------------------

Metadata
 - Data that describes other data is called metadata
 - File name
 - File size
 - Permissions
 - Ownership
 - Access time
 - And more

 - The quickest way to get information about a file is by doing a long list of the file

ls -l /etc/passwd

Long List of a File

-rw-r--r--. 1 root root 2750 Feb 9 23:07 /etc/passwd

-		rw-				r--				r--.
File type	User owner's permissions	Group owner's permissions	Permissions for other	

1				root 		root 		2750
Number of inodes the file uses	User owner	Group owner	Size of the file in bytes

Feb 9 23:07			/etc/passwd
Last modified date and time	Name of the file

 - First column is the file type
	- means regular data file

Linux File Types
Character	Type
-		Regular File
b		Block Device
c		Character Device
d		Directory
l		Symbolic Link
n		Network File
p		FIFO (pipe)
s		Socket

 - The next three characters are the user owner's permissions
	rw-

r = read
w = write
x = execute

 - Inodes, or index nodes, stores the metadata about the file, as well as a pointer to the location of the data blocks on the disk.
 - The inode of a file does not contain the name.  The file's name is not stores in the file's inode.  We need a directory inode for that.
 - Directory data is stored in directory inodes.

 - In Linux, a file name is only hidden if the first character of its name is a dot.

ls -la
	List hidden files (l = long list, a = all)

file /etc/passwd
	List the tile type
	ie. ASCII text
	The file command looks at the bits of the file to determine which type it is.

stat /etc/passwd
	Another command to show file info

Stat of a file
File: /etc/passwd
Size: 2750	Blocks: 8	IO Blocks: 4096		regular file
Device: fd00h/64768d	Inode: 2101122	Links: 1
	Size in bytes
	Number of file system blocks
	Size of the IO block = size in bytes of every block
	Type of file
	Device number
	Inode number
	Number of hard links
	Permissions
	ID number of the user owner
	ID number of the group owner
	SELinux security context

 - Each drive uses the same number for inodes, so two files on two drives can have the same inode number.
 - However, the device number in combination with the inode number makes a unique address.
 - Stat also shows (last) access, modify, and change dates.
	modify = content modified
	change = last time and attribute or content was modified
		ie. metadata would update if we changed ownership or permissions, but the file data is not changed
 - Birth = creation file.  This last item came from UNIX, and is not supported on Linux.

==========

Extended Attributes
 - Require support by the OS
 - Extensions to file
 - Stored with files on disk
 - Three major types of extended attributes
	- Extended system attributes
	- Extended security attributes
	- Extended user attributes

Extended System Attributed
 - Store file access control lists (ACLs)
	- Permissions for multiple users
	- Permissions for multiple groups
	- Inheritance
	- Backup and restore permissions

Extended Security Attributes
 - SELinux mandatory access control system
	- Layered over discretionary access control
	- System-wide rules restricting all users
 - SELinux modes
	- Multilevel security
		mimics a government security levels, ie. level 3 security clearance
	- Role-based access control
	- Type enforcement
		What Enterprise Linux mostly uses to enforce security policy
		All files, processes, and users are tagged with a type

Extended User Attributes
 - Store additional flags
	- Called extended attributes
	- Append only
	- Compress
	- Immutable
		The file can not be modified, deleted or renamed, and no data can be written to the file
		This is true even for the root user
		However, the root user can remove the immutable flag
	- Backup
		When the backup flag is set and the file is deleted, the data is backed up so we can un-delete
		 it later.

 - Not all file systems or operating systems support all extended attributes.

==========

Get extended attributes
-----------------------

touch aclfile.txt

ls -l aclfile.txt
	Take a look at the permissions on this file using a long list

setfacl -m user:root:rwx aclfile.txt
	Set an ACL on the file
	-m = modify

getfacl -t aclfile.txt
	Shows standard Linux permissions and ownership, as well as the additional ACL for the root user

 - The ls command cannot display the access control list, however, there is now a plus symbol where there used to be a dot.
	From:	-rw-rwxr--.
	To:	-rw-rwxr--+
 - This clue tells you that there's an ACL set and that you need to use the getfacl command to see it.

ls -Z aclfile.txt
	Show SELinux security context
	unconfined_u:object r:user_home_t:s0 aclfile.txt
		User is unconfined
		The role is object
		The type for tpye enforcement is user_home_t
		The security level is 0
			We didn't add this context, it was auotmatic based on rules in the SELinux policy database

Extended user attributes:

sudo chattr +i aclfile.txt
	Add an extended attribute to file (immutable)
lsattr aclfile.txt
	Viewing extended attribute
	----i---------- aclfile.txt
lsattr -l aclfile.txt
	Verbose
	aclfile.txt Immutable

Getting Extended Attributes
Task				Command
Verify existence of ACL		ls -l
Show ACL information		getfacl
Show SELinux security context	-Z option
Show extended attributes	lsattr

==========

Linux permissions overview
--------------------------

 - The standard Linux permission system came from Unix and was created 40 years ago.

Features of Standard Permissions
 - Users belong to multiple groups
	- Groups can NOT contain other groups
 - Files belong to one user
 - Files belong to one group
 - Permissions can be set for user, group, or other
 - Files: users can read, write, and execute
 - Directories: users list, create files, and traverse
 - Support privilege escalation
 - Support group owner inheritance
	- Files and directories can inherit the parent directory's group owner
 - Support default file permissions

Shortfalls of Ownership
 - Files can only belong to one user
 - Files can only belong to one group
 - Directories can only belong to one user
 - Directories can only belong to one group
 - Inheritance only for group owner
	- A child file or directory can inherit the parent directory's group owner but not its permissions
 - Permissions set for "other" are not concise
 - Backing up permissions difficult
 - No temporary permissions
 - Access Control Lists remedy most of these issues

==========

File and directory modes
------------------------

Permission Modes
 - Read
	Read permissions for files - read contents of a file
	Read permissions for directories - read the metadata of files in the directory
 - Write
	Write permissions for files - Write or modify content of a file
	Write permissions for directories - Create new files in a directory
 - Execute
	Execute permissions for files - Load files into memory and run on the CPU
	Execute permissions for directories - Enter or traverse the directory

==========

File ownership
--------------

 - The command that we use to change the ownership of a file is chown.
 - In order to change the ownership of a file, you need to be root or elevated privileges with sudo.
 - The users and groups have to exist before we can change ownership to them.
 - You can get a list of existing users by viewing the /etc/passwd file.
 - You can get a list of existing groups by viewing the /etc/group file.

chown Syntax
	chown [options] <user>:<group> <file>

chown user1 file.txt
	Setting the User Owner

chown :accounting file.txt
	Setting the Group Owner

chown User1:accounting file.txt
	Setting User and Group Owners

Exercise with ownership:
mkdir ownexercise
cd ownexercise/
pwd
touch file.txt
sudo useradd testuser
cat /etc/passwd
sudo groupadd testgroup
cat /etc/group
sudo chown testuser:testgroup file.txt
ls -l

chown -R <user>:<group> /home/<user>
	Ensure that all files in a user's home directory are owned by the user and their primary group.
	-R = recursively

==========

Permissions using the numeric method
------------------------------------

Permission Methods
 - Numeric method
 - Symbolic method

Numeric Mode
Mode	Value
Read	4
Write	2
Execute	1

 - The command we use to set permissions is chmod (change mode).
 - Initial permissions are assigned to new files based on the value of the umask.

chmod Syntax
	chmod [options] <permissions> <filename>
	chmod 750 file.txt

Exercise with permissions:
mkdir permexercise
cd permexercise/
touch file.txt
ls -l
chmod 750 file.txt
	User Owner = read/write/execute
	Group Owner = read/execute
	Other = no permissions
ls -l

==========

Permissions using the symbolic method
-------------------------------------

chmod u=rwx,g=rx,o= file.txt
	user = read/write/execute
	group = read/execute
	other = none
 - With symbolic method, we can also add permissions by changing the equal sign to a plus, or subtract permissions with a minus.

chmod u+rwx file.txt
	Add rwx to a user

chmod o-x file.txt
	Take execute permissions away from other

 - You can also group the positions:
	Take away execute for user, group, and other:
	chmod ugo-x file.txt
	Alternatively, we can use a for all
	chmod a-x file.txt

sudo useradd bob
sudo chmod -R a-x /home/bob
	Remove all execute permissions for every file in /home/bob

==========

Initial permissions using umask
-------------------------------

 - When files are created, initial permissions are applied auotmatically.
 - These permissions are calculated based on a bit mask called umask

umask
	View umask
		0022
	Can be either three characters or four, can leave leading zero on or off for standard permissions
	umask isn't the same format as numeric permissions such as 754
umask -S
	View umask in symbolic notation
		u=rwx,g=rx,o=rx

Initial Directory Permissions
	777 = Max Initial Directory Mode
 777 Max Initial Directory Mode
-022 umask
----
 755 Initial Directory Mode
	rwxr-xr-x

Initial Directory Permissions
	666 = Max Initial File Mode
	For security reasons we don't allow execute permissions on files by default
	This keeps files from being automatically executable after being copies from one place to another,
	 including files downloaded from the internet
 666 Max Initial File Mode
-022 umask
----
 644 Initial File Mode
	rw-r--r--

 - We can temporary change our umask by using the umask command.

umask 0002
	rwxrwxr-x default permissions for directories, rw-rw-r-- for files

 - This only works for our current login session.
 - If a user wants to change their umask, they can add it tot heir bash startup file using an editor.

vi ~/.bashrc
	add the line:
	umask 0002

 - If an administrator wants to change the system-wide umask, they can add it to a file in /etc/profile.d

sudo vi /etc/profile.d/umask.sh

if [ "$UID" -ge 1000 ] ;
	umask 0002
fi

-ge for greater than or equal to

==========

Special file bits: SUID and SGID
--------------------------------

 - There are additional special bits for privilege escalation on executable files.

Special Bits on Files
 - Set User ID (SUID)
	- Run as user owner of the file
 - Set Group ID (SGID)
	- Run as group owner of the file
 - Sticky
	- Historically in Unix, if you set the Sticky bit on a program, it would remain in swap making it execute
	 faster the next time it is run.
	- Some versions of Unix and BSD still maintain this functionality, but it has never existed in Linux.
	- Linux caches all executables for faster execution anyway, so there's little need for a Sticky bit.

ls -l /usr/bin/su
	-rwsr-xr-x. 1 root root 50448 Apr 24 05:39 /usr/bin/su
	The file /usr/bin/su is bright red

 - The permissions in this case for the User Owner are rws.
 - The s in the User Owner's execute position means that we have SUID bit set.
 - If the s is lowercase then the underlying execute bit is also set.
 - If the S is uppercase then the execute permissins are not set.

 - When the S exists in the Group Owner permissions, then the SGID is set.
	-rwxr-sr-x.
 - Lowercase s = execute permissions are set
 - Uppercase S = execute permissions are not set

 - When the SUID bit is set, and if regular users such as user1 executes the command, their privileges get elevated to that of the User Owner's.
 - In our example, user1 would be executing the su command as root.
	-rwsr-xr-x. 1 root root 50448 Apr 24 05:39 /usr/bin/su
 - This means this command would have all of the power of the root user.

Special Bit Values

Mode	Value
SUID	4
SGID	2
Sticky	1

-rwsr-xr-x. 1 root root 50448 Apr 24 05:39 /usr/bin/su
	SUID is set so 4 + 0 + 0 = 4
	Our original permissions are 755
	Add the 4 in front for total permissions in numeric mode with SUID set are 4755

sudo chmod 4755 /usr/bin/su
	Set SUID permissions
sudo chmod u+s /usr/bin/su
	Set SUID permissions in symbolic mode

 - The SGID bit is very similar to SUID.
 - When we have SGID set, the s resides in the execute position of the Group Owner's permissions.
 - When a regular user, such as user1 executes a command with SGID set, it runs with the privileges of the Group Owner of the file, in this example the screen group:
	-rwxr-sr-x. 1 root screen 0 Jan 5 13:26 /usr/bin/screen
 2 4 4 4 SGID value is the leading 2
 0 2 0 0
+0 1 1 1
--------
 2 7 5 5

sudo chmod 2755 /usr/bin/screen
	Set SGID permissions
sudo chmod g+s /usr/bin/screen
	Set SGID permissions in symbolic mode

 - Because these commands allow privilege escalation without prompting for a password, it may be advantageous to know where in the file system they are for security reasons.
 - We can use the find command to locate SUID and SGID files.

sudo find / -perm -4000
	Find all files with the SUID bit set

sudo find / -perm -2000
	Find all files with the SGID bit set

==========

Special directory bits: SGID and sticky bit
-------------------------------------------

Special Bits on Directories
 - Set user ID (SUID)
	- No effect on directories
 - Set group ID (SGID)
	- Provides group inheritance for files and directories created inside the directory
 - Sticky
	- Only owners can delete their own files

cd /home
pwd
sudo mkdir accounting
ls -l
	Since we created the directory using sudo it's owned by the root user and the root group
sudo groupadd accounting
sudo chown :accounting accounting/
sudo chmod 2770 accounting
	Add the SGID bit as well as right permissions for the Group Owner
ls -l
	drwxrws---.	2 root	accounting	6 Oct	5 14:09 accounting

SGID Bit on Directories

	drwxrws---.	2 root	accounting	6 Oct	5 14:09 accounting

 - SGID bits on directories represent the only inheritance in standard Linux permissions and ownership.
 - All files and directories created inside of your accounting directory will inherit the Group Owner, accounting.
 - If user1 creates a file in the accounting directory, it will be owned by user1 and the accounting group.
	-rwxr-sr-x.	1 user1	accounting	0 Jan	5 13:36 /home/accounting/file.txt

 - This allows us to create a directory for group collaboration.
 - For our setup, all users creating files in this directory would need to belong to the accounting group in order for them to have right access.

sudo useradd -G accounting ted
	-G = supplemental group
sudo passwd ted
cat /etc/group
	accounting group with ted in it at the bottom
su - ted
cd /home/accounting/
pwd
touch file.txt
ls -l
	-rw-rw-r--. 1 ted accounting 0 Oct 5 14:14 file.txt
exit

Setting a sticky bit:

cd /home
sudo mkdir stickydir
sudo chmod 1777 stickydir/
ls -l
	drwxrwxrwt. 2 root	root	6 Ocr 5 14:14 stickydir
	We should see that our directory has a t in the execute position of the permissions of other.
	t = execute for other is set
	T = execute for other is not set

 - The purpose of the sticky bit on a directory is to keep users from deleting or moving each other's files.
 - The sticky bit is used mainly for world writable shared directories like /tmp

cd /home/stickydir
touch file.txt
chmod 777 file.txt
ls -l
	-rwxrwxrwx. 1 user1 1051 0 Oct 5 14:15 file.txt
su - ted
ls -l
	-rwxrwxrwx. 1 user1 1051 0 Oct 5 14:15 file.txt
	We can see that file.txt has twx for user, group, and other.
	This means that we have full access to it, including delete..
rm file.txt
	rm: cannot remove 'file.txt': Operation not permitted
	Even though ted has rwx permissions on the file he still can't remove it.
ls -ld /tmp
	d = directory
	drwxrwxrwt. 12 root root 4096 Oct 5 14:17 /tmp
	You should see the t in the other permissions section.

==========

Access control lists overview
-----------------------------

Limitations of Stndard Permissions
 - Files and directories belong to one user
 - Files and directories belong to one group
 - Permissions set for "other" are not concise
 - Inheritance only for group ownership
 - Cannot back up and restore permissions
 - No temporary restriction

 - For example, desired permissions on /var/reports:
	Accounting - Read, write, and execute
	Marketing - Read and execute

 - The closest we can get to satisfy these objectives using standard Linux permissions is to make the accounting group the Group Owner, and set their permissions to be rwx.
	-rwxrwxr-x. 1 root accounting 2315 Sep 12 14:39 reports
 - Since a directory can only be owned by one group, we have no other choice but to have the marketing group access the directory using other permissions.
 - The problem is that everyone would be able to access the directory, not just the marketing group.
 - Also, if we needed to set permissions for any other groups, we're stuck.
 - Access Control Lists, or ACLs, are layered onto Linux permissions and extend them in new ways.

Advantages of ACLs
 - Permissions for multiple users on a file or directory
 - Permissions for multiple groups on a file or directory
 - Support permissions inheritance
 - Easy backup and restore of permissions
 - Easy temporary permission restriction

Disadvantages of ACLs
 - Not always installed
 - Not built into Linux
 - Can be turned off
 - Require additional, unfamiliar commands

File Name, User, and Group Owners

# file: reports/
# owner: root
# group: root
user::rwx
group::rwx
group:accounting:rwx
group:marketing:r-x
mask::rwx
other::---
default:user::rwx
default:group::rwx
default:group:account:rwx
default:group:marketing:r-x
default:mask::rwx

Breaking it down:

# file: reports/
# owner: root
# group: root
	File name, User Owner, Group Owner

user::rwx
group::rwx
	User and Group Owner permissions
	The User Owner is root and has rwx permissions
	The Group Owner is the root group which also has rwx permissions

 - If ACLs were disabled or this drive was moved to a system that didn't use ACLs, then only root would be able to access this directory.
 - This is a pretty safe baseline for permissions with ACLs.
 - Now there's an ACL giving the accounting group rwx permissions and the marketing group r-x permissions.

default:group:account:rwx
default:group:marketing:r-x
	There's also a default ACL for inheritance.
	Any file or directory created in the reports directory would also inherit the group ACLs listed above.

 - The accounting group would have twx access to future files, and the marketing group would have r-x access to future files.

mask::rwx
	The mask is the maximum allowed permissions.
	If an admin wanted to temporarily limit access, they could just take permissions away from the mask.

 - ACLs are not built into Linux, but they are turned on by default in Enterprise Linux 8.

==========

Read access control lists
-------------------------

 - If ACLs are not installed, you'll get an error message saying they are not supported.
 - Once they're installed, you'll need to mount the file system with ACLs turned on.

mkdir ~/aclexercise
cd ~/aclexercise
pwd
touch aclfile
ls -l
getfacl aclfile
	# file: aclfile
	# owner: user1
	# group: user1
	user::rw-
	group::rw-
	other::r--
getfacl -t aclfile
	Display in tabular format
	# file: aclfile
	USER	user1	rw-
	GROUP	user1	rw-
	other		r--

setfacl -m user:root:rwx aclfile
	Set an ACL for the root user.
ls -l
	-rw-rwx--+ 1 user1 user1 0 Apr 18 16:11 aclfile
	The symbol after permissions is now a plus, this tells you an ACL exists
getfacl -t aclfile
	# file: aclfile
	USER	user1	rw-
	user	root	rwx
	GROUP	user1	rw-
	mask		rwx
	other		r--

getfacl -R /home > home-perms.txt
	-R = recursive
	Permissions can be stored to this file and then restored later.

 - A message will tell you that permissions were stored without the leading forward slash.
	getfacl: Removing leading '/' from absolute path names
 - This means none of the permissions are stored with an sbolute path name.
 - To restore them, you'd need to go back to this exact directory before running the restore command.
 - This file contains the permissions and ownership for all files in /home.

==========

Set access control lists
------------------------

Syntax for setfacl:

setfacl -m user:<username>:<permissions> <file>
	-m = modify
setfacl -m u:user1:rwx /home/file.txt

cd ~/aclexercise/
touch datafile.txt
sudo useradd bob
sudo groupadd accounting
sudo groupadd marketing
cat /etc/passwd
cat /etc/group
setfacl -m user:bob:rwx datafile.txt
getfacl -t datafile.txt
	# file: datafile.txt
	USER	user1	rw-
	user	bob	rwx
	GROUP	user1	rw-
	mask		rwx
	other		r--

setfacl -m group:<groupname>:<permissions> <file>

setfacl -m group:test:rwx file.txt
	The group has to exist or it will give you a strange error message where the error starts near character 7.

setfacl -m user:bob:rwx,group:accounting:rx datafile.txt
	Set user ACL as well as group ACL
	Same as: setfacl -m u:bob:rwx,g:accounting:rx datafile.txt

 - If we set a user ACL and do not specify the user, it sets the standard permissions for the User Owner.

setfacl -m user::rwx datafile
is the same as
chmod u=rwx datafile.txt

Set ACLs recursively:

sudo setfacl -R -m user:bob:rwx /home/bob
	We have to elevate privileges because we're setting ACLs on someone else's files

==========

Configure inheritance with default access control lists
-------------------------------------------------------

 - Standard Linux permissions only have one type of inheritance in the form of the SGID bit on directories.
 - In that case, the files and directories created inside inherit the Group Owner of the parent directory, which there can only be one of.
 - For example, is a user named bob creates files in the directory named datadir, the user owner would be bob but the group owner would be accounting due to the SGID bit.
 - Only the Group Owner of the parent directory is being inherited, and not the permissions.

 - ACLs go much further as they let files and directories inherit any number of user or group permissions.
 - These ACLs are called default ACLs.

 - If you want to allow a user to access a directory, you set a regular file ACL on the directory.
 - If you want that user to access all files and directories created in the future inside of the directory, then set a default ACL.
 - Usually, you'll need to do both of these operations.

cd ~/aclexercise/
mkdir data
touch data/file.txt
touch data/photo.jpg
cat /etc/passwd
	verify we have a user named bob
	sudo useradd bob
setfacl -m user:bob:rwx data
getfacl -t data
	# file: data
	USER	user1	rwx
	user	bob	rwx
	GROUP	user1	rwx
mask			rwx
other			r-x

setfacl -R -m user:bob:rwx data
	Now all files that currently exist in the directory are accessible to bob as well.
setfacl -d -m user:bob:rwx data
	-d = default
	Create a default ACL for any future files that will be created in the directory.
touch aclfile.txt
	Create as any user besides bob, ie. user1
getfacl -t aclfile.txt
	# file: aclfile.txt
	USER	user1	rw-
	user	bob	rwx
	GROUP	bob	rwx
	mask		rw-
	other		r--

==========

Delete access control lists
---------------------------

cd ~/aclexercise
mkdir acldir
setfacl -m user:root:rwx acldir
setfacl -m group:root:rwx acldir
setfacl -m group:audio:rwx acldir
setfacl -d -m user:root:rwx acldir
getfacl aclfile

 - We use setfacl to delete ACLs.

Delete ACL Syntax:

Function		Option
Remove specific ACL	-x
Remove all default ACLs	-k
Remove all ACLs		-b

Deleting Specific ACLs:

setfacl -x user:root accounting/

setfacl -x root accounting/
	Of you just specify the name that the ACL is set on, then setfacl will assume it is a user ACL.

Deleting Specific Default ACL:

setfacl -x default:user:root accounting/

Deleting all Default ACLs:

setfacl -k accounting/

Deleting all ACLs:

setfacl -b accounting/


getfacl acldir
setfacl -x group:root acldir
getfacl acldir

setfacl -x root acldir
getfacl acldir

setfacl -k acldir
getfacl acldir

setfacl -b acldir
getfacl acldir
	We've removed all ACLs

setfacl -R -b acldir
	Recurse into acldir and remove ACLs from any files inside it, as well as the ACLs on the acldir itself.

==========

Troubleshoot access control
---------------------------

 - Check to see if the account is in good standing, or locked, using the passwd command.

Check status of user account:
	sudo passwd -S <username>

 - If there's an l after the name, it's locked.
 - If the user is able to login, then move on to the file ownership and permissions.
	Look at file permissions, group ownership, and ACL if it has one

ls -l finances.cvs
	See permissions.

 - Take note of which user and group owns the file.
 - A user can only gain access to a file if they have traverse permissions to it, so check that first.
 - Have them cd into each directory of the path until they can see the file.
 - Then check the ACL on the file itself.

getfacl finances.csv

 - A user can only access the file as the file's owner, a member of the file's group, through an access control list applied to the file, or under the category of other (not recommended).

 - Execute permissions
 - Privilege escalation

Check sudo permissions:
	less /etc/sudoers

 - Perhaps the sudoers file doesn't have a specific access control line for the user, but the user may need to be in a sudo or OS group, such as admin, to elevate privileges.
 - If there is a line allowing members of the admin group to use sudo, ensure the user is in that group by viewing the /etc/group file.

 - In rare occasions, a file needs to have SUID or SGID bits set to elevate privileges.
 - Check to see if they've been removed using rpm.

rpm -V <package name>
	If there's a capital M in the output, then the permission mode has changed.
	If there's a u or g then the user or group have changed
rpm --setperms <package name>
rpm --setugids <package name>

 - Unfortunately, you can't reset permissions using the package manager on Debian based systems, so this is an RPM only trick.

 - The next step is to ensure the program resigns at a volume with exec turned on.
 - Use the mount command to verify that applications are allowed to be executed at the file's path.

 - Check mount options.
tmpfs on /tmp type tmpfs (rw,nosuid,nodev,seclabel,inode64)

 - Look for noexec on the mount point, or nosuid and nosgid, if those permissions are required.

 - Failed authentication
	Authentication logs
	/var/log/auth.log - Debian
	/var/log/secure - RHEL based

 - Mandatory access control (MAC)
	SELinux logs

 - Check is SELinux is enabled:
	sestatus

 - If SELinux is enabled, then Audit MAC logs

Check MAC logging:
	sealert -a /var/log/audit/audit.log
	less /var/log/messages

Check is AppArmor is enabled
	aa-status

==

Quiz notes:

Default ACLs provide inheritance for user and group permissions.  Default ACLs only provide inheritance.  Default ACLs do not provide ownership inheritance.

SGID bits on directories allow the group owner to be inherited.

What do both SUID and SGID bits provide on a file?
Privilege escalation.  On a file SUID and/or SGID will provide privilege escalation. Not so on a directory.


==========

12. Mandatory Access Control
============================

Set enforcing and permissive modes for SELinux
----------------------------------------------

Discretionary Access Control
 - Discretionary access control is a means of restricting access to objects based on the identifty of subjects and/or the groups to which they belong.
 - Standard Linux permissions, Access Control Lists, SUID and SGID special bits, as well as su and sudo are examples of discretionary access control.
 - Access control is discretionary in that a subject with certain permissions can pass those permissions on to other subjects.

Mandatory Access Control
 - Mandatory access control is an additional layer over discretionary access control.
 - The operating system constrains the ability of a subject to access an object.
 - Mandatory access control is made up of rules allowing subjects some sort of access to objects.
 - Subjects are usually processes which are run by users.
 - Objects are the resources they're trying to access such as files, directories, IO devices, pipes, network ports.
 - The access is an action performed by the subject on the object, such as read, write, delete or create.

 - The security context, or label, is the tags that SELinux stores for subjects and objects.
 - All subjects and objects will have a security context.
 - This security context is stored in the extended attribute section of the file metadata.

Process of subjects accessing objects, adding in SELinux bits:
 - The subject, Vim, requests access to the object which is file.txt
 - The SELinux security server queries the SELinux policy database of rules.
 - If based on those rules, permission is granted, then Vim will access file.txt
 - If permission is not granted, then a denied access message will be added to the access vector cache.
 - These messages are available through the operating system log files.

SELinux has several operating modes.
 - Enforcing mode, where the security policy is being enforced.
 - Permissive mode, where the policy is consulted and messaged are printed, but the policy is not enforced.
	- This is good for troubleshooting SELinux policy issues.
	- The application is allowed to run and all policy violations are logged.
	- There are times when having SELinux set to permissive will still deny a subject accessing an object.
 - Disabled, SELinux is turned off and no mandatory access control system is in place.

SELinux has different enforcement policies.
 - Type enforcement is the default type of mandatory access control used in the targeted policy.
 - Role-based access control which assigns a role to SELinux users and enforces access control that way.

SELinux also supports multi-level security, which assigns a security level to various subjects and objects.
 - For instance, in a military environment, you may have a certain clearance level which gives you access to certain resources.
 - Multi-category is similar in that it categorizes objects and makes policy decisions based on the category.
	- This is useful with containerization of processes.

sestatus
	Show current SELinux mode.
getenforce
	Show current SELinux mode.
sudo setenforce permissive
	Set SELinux mode.
	This is temporary.
	Otherwise, we'd have to edit the /etc/selinux/config file and reboot
less /etc/selinux/config

 - If you want to disable SELinux, it cannot be done live.
 - The /etc/selinux/config file needs to be edited and the system has to be rebooted.

==========

List and identify SELinux file and process context
--------------------------------------------------

 - SELinux subjects are usually users and processes.
 - All subjects and objects in SELinux have a security context or label.
 - To get the security context of our user, we'll use the id command.

id -Z
	Show security context of our user
	unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
	
 - unconfined_u = our SELinux user
 - unconfined_r = our role for role-based access control
 - unconfined_t = our type for type enforcement
 - The last section is the security level used by multilevel and multi-category security.

ps -eZ
	Look at the security context of all running processes

 - Files also have a security context, as they are object.

ls -lZ
	Get the security context of files

 - SELinux supports domain transitioning
	- Subjects can move from one type to another if allowed in the security policy

ls -lZ /usr/bin/passwd
	The passwd command's type is passwd_exec_t
	When passwords are set they are written to the /etc/shadow file

sudo ls -lZ /etc/shadow
	The /etc/shadow's type is shadow_t

 - You might think that as a rule in SELinux that sllows subjects with a type of password_exec_t to read and write to objects with a type of shadow_t, but that isn't quite how it works.
 - As a test, open a new terminal and run `passwd` but don't answer the prompt
 - In a different terminal run `ps -eZ`
	- Now we see that the running passwd command's type is passwd_t, and not passwd_exec_t.
 - When the passwd command is run, it is allowed to transition to the password_t type.
 - There is a rule that allows a ubject of type password_t to write to an object with a type of shadow_t.
 - Without transitioning to the password_t type, the password command would not be able to write to the shadow file.
 - Processes can transition from one type to another temporarily to execute code n that type if the security policy allows it.
 - This is similar to the sudo command.
	- When we execute a command using sudo we transition to the superuser temporarily.

==========

Restore SELinux default file contexts
-------------------------------------

ls -lZ /home
	The security context of /home is user_home_dir_t
touch newfile.txt
ls -lZ newfile.txt
	It's type is user_home_t
changecon -t etc_t newfile.txt
	Change the context of newfile.txt to etc_t
	We don't need to elevate privileges when we're doing this to our own files
ls -lZ
	Verify the type is etc_t
restorecon newfile.txt
	The policy database knows what the security context of the files in /home should be
ls -lZ
	Now we can see the type has changed to user_home_t

 - If you want to reset the security context of every file in the operating system, you'll want to relabel the drive.
 - This means that SELinux will restore or relabel every file back to its default security context.
 - To do so, we just need to create a hidden file in the root directory named .autorelabel, and reboot.

sudo touch /.autorelabel
	The next time you reboot, the security context of all files in the entire operating system will be set
	 back to the default context.
	Expect the boot process to take longer this one time.
	When it's done relabeling all files, it deletes the hidden autorelabel file that we created.

 - If you're positive that you want a file in your home directory to have a different security context, and you don't want a restorecon or a relabel to set, then you can change the policy database using the semanage command.

sudo semanage fcontext -a -t etc_t /home/user1/newfile.txt
	This will add an entry for the type etc_t on the file named newfile.txt
sudo semanage fcontext -l | grep newfile
	-l = list
restorecon newfile.txt
	Restore
ls -lZ newfile.txt

 - It's best to change the policy and then use restorecon to set the context, rather than use changecon.
 - Changecon can be used for temporary context changes to troubleshoot.

