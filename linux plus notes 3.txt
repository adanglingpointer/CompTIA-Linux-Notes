Linux storage system overview
-----------------------------

Types of Storage
 - File storage
 - Block storage
 - Object storage

File Storage
 - Hierarchy of files in folders
 - Data in files
 - Metadata contains path to file
 - Local file systems
 - Network file systems - NFS (Network File System), CIF (Windows Common Internet Filesystem)

Block Storage
 - Exposes blocks of binary data
 - Blocks have unique identifiers
 - Storage system reassembles blocks
 - Storage area networks (iSCSI)

Object Storage
 - Manages data
 - Links data to associated metadata
 - Data is stored in discrete objects
 - Single repository
 - Red Hat Ceph

ATA Drives
 - local drives in a legacy system
 - Parallel ATA drive with a flexible ribbon cable with 80 wires
 - Two drives per cable
	To have more than two drives, a system needs multiple controllers
 - Speed: 133 MB/sec
 - /dev/hda, hdb

SCSI Drives
 - Small Computer System Interface
 - higher end legacy systems
 - Parallel SCSI drive with larger flat ribbon cable with 168 wires, used mostly for servers
 - 16 drives per cable
 - Speed: 320 MB/sec
 - /dev/sda, sdb

SATA Drives
 - newer systems
 - Serial ATA with narrow serial cable
 - One drive per cable
	Can be a spinning disk, or a Solid State Drive
 - we measure serial interfaces with Bits per second instead of Bytes
 - Speed: 6 Gbps
 - /dev/sda, sdb

SAS Drives
 - Serial Attached SCSI
 - Parallel SCSI was replaced by Serial Attached SCSI (SAS)
 - Backward compatible with SATA
 - Speed: 12 Gbps
 - /dev/sda, sdb

NVMe Drives
 - Non-Volatile Memory Express
 - no cable at all, plugs into slot like a memory stick
 - The structure of the internal components is very similar to a solid state SATA drive,
	the only difference being the interfaces direct via a PCI Express bus
 - Speed: 32 Gbps
 - /dev/nvme0n1p1
	nvme followed by device number, namespace number, and partition number

USB Drives
 - Thumb drive
 - SSD in USB case
 - Speed: 5-20 Gbps
 - /dev/sda, sdb

Partitioning the drive = divide drive into smaller, more manageable sections
OS	Users	Data

 - Older BIOS space systems can only have 4 primary partitions with a maximum size of 2 TB
	A later trick was developed to allow one of the four partitions to be made into an extended partition,
	 and then divided again into a maximum of 12 logical drives.
 - The BIOS partition table is stores in the master boot record in the first sector of the drive
 - BIOS was replaced by the Unified Extensible Firmware Interface (UEFI)
 - One of the improvements was the GUID Partition Table (GPT) which supports up to 128 partitions
	with a total capacity of 9.4 Zetabytes (ZB)(9.4 billion Terabytes)

 - Linux has the additional ability to combine partitions and drives into volume groups,
	and divide the resulting group into smaller logical volumes
 - This is called LVM

[Part 1]		[Part 2]		[Part 3]
↓			↓			↓
			[Volume Group]
↓			↓			↓
[Logical Volume]	[Logical Volume]	[Logical Volume]

 - New drives can be added to the volume group allowing you to increase the size of the logical volume without
	taking it offline.
 - Each logical volume acts as a flexible partitions.
 - It also allows you to swap drives from underneath the logical volumes while they're being used.
 - Unlike partitions, space utilized for logical volumes does not need to be continuous.

 - Drives can also be combined into a RAID (Redundant array of independent disks)

[Drive 1]	[Drive 2]
↓		↓
	[/dev/sda]

 - RAID can be accomplished on Linux using LVM or the mdadmin tool

 - Drives, partitions, logical volumes, and RAID devices can be combined in many different ways to solve your
	storage needs.

[Drive 1]	[Drive 2]	[Drive 3]	[Drive 1]	[Drive 2]	[Drive 3]
↓		↓		↓			↓		↓		↓
		[/dev/sda]					[/dev/sdb]
		↓							↓
				[Volume Group]
				↓
				[Logical Volume]
				↓
				[EXT4]

 - The resulting device could be encrypted using LUKS for security [LUKS Encrypted Volume] (instead of EXT4),
	or just formatted with a file system mounted on a directory to allow access
	 [ext4 - /media/storage]

Linux File Systems (current)
 - ext4
 - XFS
 - Btrfs

Legacy Linux File Systems
 - ext2
 - ext3
	Added journal
 - Maximum file size: 2 TB
 - Maximum file system size: 16 TB

ext4 File System
 - Supports SSDs
 - Maximum file size: 16 TiB
 - Maximum file system size: 1 EiB (1 billion Gigabytes)
 - ext2/ext3 can migrate to ext4 without reformatting

FXS File System
 - Default on Enterprise Linux from version 7
 - 64-bit file system
 - Created by Silicon Graphics for Unix
 - Maximum file system size: 8 EiB

Btrfs File System (pronounced butter FS)
 - Created as a response to Sun Microsystems ZFS
 - Supports:
	- Partitioning
	- RAID
	- Logical volumes
	- Snapshots
	- Compression
 - Maximum file size: 16 EiB

 - When it comes to virtual memory, instead of using a page file stored on disk, Linux by default uses an
	entire partition
 - This provides a faster virtual memory interface that is not subject to fragmentation,
	but does require a separate partition or logical volume.

Specialty File Systems
 - Enterprise Cryptographic File System (eCryptfs)
	Applies POSIX-compatible encryption protocols to data before it's written to disk

Non-Linux File Systems (supported by Linux)
 - VFAT/exFAT (Microsoft)
 - NTFS (Microsoft)
 - HFS/HFS+ (Apple)
 - ISO 9660/UDF (optical disks)
 - ZFS (Sun Microsystems)

 - There are licensing issues with some of these file systems, restricting them from being included in the kernel.
 - They're handled in user space directly or through the FUSE file system, which acts as a bridge between the 
	kernel and user-created file systems

Kernel Space		User Space
[Kernel]	↔	[FUSE]↔[ZFS]

Remote File Systems (supported by Linux)
 - SMB (Windows)
 - CIFS (Windows)
 - NFS (UNIX)

==========

Prepare for handling storage
----------------------------

To practice in VirtualBox

 - Shut down VM
 - Settings
 - Storage
 - Right click Controller: SATA
 - Hard Disk
 - Create
 - Keep default of VDI
 - For storage type keep default of dynamically allocated so it doesn't take up extra disk space
 - For LVM and RAID exercises, you need a lot of drives, but they don't need to be very large so change the size
	to 1 GB
 - Also take note of the virtual disk name, i.e. rhhost1_1.vdi
 - Click Finish
 - Click Choose to attach to VM
 - Create 3 more drives the same way, incrementing the name for each one
 - Power VM back up again

==========

Create partitions using fdisk
-----------------------------

cat /proc/partitions
	get a list of drives and partitions that the kernel recognizes, comes from the kernel directly
lsblk
	list block devices
	gives a visual list of the drives and their partitions or logical volumes
sudo blkid
	list partition labels and UUID numbers
	it also shows which file system the drive is formatted with
sudo fdisk -l
	read the partition table from the drive directly
sudo fdisk -l /dev/sda
	list partitions on only one drive

 - fdisk is getting the data directly from the drive's partition table
 - /proc/partitions lists the partitions that the kernel recognizes, and is stored in RAM
 - In some cases, if you modify a drive's partition, the kernel may not update it's partition table because the
	drive is locked by a process, or because one of its partitions is mounted.
	If possible, unmount the partition and then use partprobe to update the partition table.

sudo partprobe
	update the partition table
	then check /proc/partition again
	if this still doesn't match fdisk, you may have to reboot

 - Legacy systems use a BIOS to boot the machine (rather than UEFI and GUID partition table)
 - BIOS stores its partition table in the MBR - master boot record
 - Although fdisk supports GUID partitions now, older versions did not, so to edit partitions you had to use gdisk
 - Everything we do here in fdisk can be done in gdisk as the interface is virtually the same

sudo fdisk /dev/sdb
	edit the partitions on /dev/sdb
	if no partition table is found, a new DOS partition table is created (old BIOS style partition table)
m
	help menu
d
	delete a partition
n
	create a new partition
p
	print partition table
t
	change a partition type
w
	write partition table to disk and exit
q
	quit without saving changes
g
	create a new GPT partition table
	this is desirable unless you're on a legacy system with BIOS

g
n
1
2048
+500M
	create a 500MB partition and leave the rest of the disk free
p
	print partition table to verify
w
	write and exit

sudo udevadm settle
	register the partition to let the kernel know it has changed
cat /prov/partitions
	verify the kernel recognizes the new partition

 - Once you've created partitions, you can use them in LVM or format them directly using tools such as mkfs
 - Once you have formatted it, you can mount it

==========

Create partitions using parted
------------------------------

Older versions of parted could:
 - resize partitions
 - copy partitions
 - move partitions
 - format partitions
 - rescue

Some of these features were removed after version 2.4 including:
 - check
 - cp
 - mkpartfs
 - move
 - resize

 - gparted is a GUI tool, but is different from parted

sudo parted
	run parted in interactive mode
help
	show list of commands
help print
	show more info about a specific command such as print
print
	display the partition table, much like typing p in fdisk
print all
	print all drives and partitions, similar to fdisk -l
print devices
	a shorter more concise list drives
select /dev/sdc
	select a specific drive to edit
print free
	get stats on the drive and show free space
mktable gpt
	this is the same as 'mklabel'
	created a GPT style partition table
print
	verify partition table was created
mkpart primary 1MiB 500MiB
	create a new 500 MB partition now they we have a partition table
	the choice of type can be primary, extended, or logical
	because we created a GPT partition table, all partitions will be primary
quit
	exit parted
sudo udevadm settle
	register the partition to let the kernel know that it has changed
	you may not have to do this depending on which drive you're partitioning but it's a good practice
cat /proc/partitions
	verify that the kernel recognizes the new partition

 - creating a bare/raw drive in Virtual Box will likely not have a partition table at all
 - when you buy physical drives, usually they come with a partition table already
 - once you've created partitions, you can use them in LVM or format them directly using disk formatting tools
	such as mkfs

==========

Manage LVM volumes and volume groups
------------------------------------

Logical Volume Management (LVM)
 - resizing volumes
 - combining volumes
 - moving volumes
 - adding additional drives
 - hot replacing underlying drives

lsblk
	verify partition exists
sudo pvcreate /dev/sdb1
	prepare partition for LVM
sudo pvs
	physical volume summary
	verify the volume format is now LVM
sudo pvdisplay
	show more info about physical volumes
sudo vgcreate vgdata /dev/sdb1
	create a volume group named vgdata and include our physical volume
sudo vgs
	verify with volume group summary
sudo vgdisplay
	show more volume group information

 - To reference volume groups use the name only without the path
 - Volume groups are an abstraction, so they don't have a physical location

sudo lvcreate --name lvdata --size 495M vgdata
	create a logical volume inside of the volume group
	This will create a new logical volume that's 495 MB in size, named lvdata in the vgdata volume group.
	We have to make the logical volume slightly smaller than the volume group to be sure that it will fit.
sudo lvs
	verify
sudo lvdisplay
	more info

 - There are two different paths you can use to refer to logical volumes

LVM Volume Path Names
 - /dev/VolumeGroupName/LogicalVolumeName
 - /dev/mapper/VolumeGroupName-LogicalVolumeName

Formatting tools
 - mkfs
	simpler
 - mke2fs
	more powerful

sudo mkfs -t ext4 /dev/vgdata/lvdata
	format our logical volume as ext4
sudo blkid
	verify

 - To make the logical volume accessible, you'll need to mount it

sudo mkdir /media/lvdata
	create a mount point
sudo mount /dev/vgdata/lvdata /media/lvdata
	mount the logical volume
df -Th
	show file system including type and human readible format

 - Drives and logical volumes mounted manually won't survive a reboot without adding them to the /etc/fstab
	the file system table

sudo vi /etc/fstab
	edit
i
	insert mode

add the end of the file add:
/dev/vgdata/lvdata /media/lvdata ext4 defaults 1 2

/dev/vgdata/lvdata	/media/lvdata	ext4		defaults		1	2
logical volume path	mount point	file system	filesystem options

defaults include rw, suid, dev, exec, auto, nouser, async
1 = the fifth volumn is to include this drive in a backup using the dump command
2 = the last column is the order to do a file system check on bootup
	root should always be 1, and other drives 2 or higher if to be checked, and 0 if not

esc, :x!
	save and exit

sudo umount /media/lvdata
	unmount volume
sudo mount -a
	reads fstab and attempts to mount all drives that are not mounted

==========

Expand existing logical volumes
-------------------------------

cat /proc/partitions
	list partitions
	if a partition didn't exit, it would need to be created using fdisk or parted

sudo pvcreate /dev/sdc1
	make sdc1 a physical volume
sudo pvs
	verify

 - Normally we would create a new volume group at this point, but for this exercise we're going to extend an
	existing volume group

sudo vgs
	list all volume groups
sudo vgextend vgdata /dev/sdc1
	extend the vgdata volume group by adding the new physical volume to it

 - The next step is to resize the logical volume

sudo lvs
	verify logical volume size
sudo lvresize -l 100%VG /dev/vgdata/lvdata
	resizing logical volume
	when we're specifying the logical volume, we provide the full path to it
df -h
	verify the final system size of lvdata

 - Since/if lvdata is still mounted, the file system size is the old size
 - Because we formatted our logical volume as ext4, we'll resize it using resize2fs
 - lvresize command can now resize the filesystem as well, older versions could not

sudo resize2fs /dev/vgdata/lvdata

df -h
	verify again, logical volume and it's file system are expanded to the new size

==========

Reduce existing logical volumes
-------------------------------

 - lvresize can be used to unmount and remount volumes, as well as resize file systems.
 - We're going through the manual process first, as older versions may not support these features.
 - Although it's a good idea to always unmount a file system when resizing it, we can leave it mounted when
	increasing the size.
 - However, when we decrease the size, we have no choice but to unmount the volume first.
 - Some filesystems like XFS can not be resized down, only up.

sudo umount /dev/vgdata/lvdata
	unmount volume
sudo e2fsck -ff /dev/vgdata/lvdata
	run a file system check
	if the filesystem passes all 5 checks, then proceed
sudo resize2fs /dev/vgdata/lvdata 500M
	resize filesystem
sudo lvresize -L 500M /dev/vgdata/lvdata
	reduce the logical volume size to 500 MB
sudo lvs
	verify
sudo mount /dev/vgdata/lvdata /media/lvdata
	mount filesystem
df -h
	check size

sudo lvresize -r -L 400M /dev/vgdata/lvdata
	will prompt to unmount
	will reduce the logical volume using lvresize, newer method
sudo lvresize -r -L 600M /dev/vgdata/lvdata
	this will increase or decrease size based on what's specified vs the size it already is

 - Using the newer syntax, lvresize is doing all of the legwork for us by unmounting it, resizinf the filesystem,
	reizing the logical volume, and mounting it back up.

==========

Create EXT filesystems
----------------------

 - Before you can use a partition or logical volume in Linux, you need to put a file system on it.
 - This process is called formatting the drive.
 - The standard tool to format filesystems is mkfs

ls /sbin/mk*
	show all mkfs programs

Reformat lvdata logical volume:

sudo umount /dev/vgdata/lvdata
	unmount if it's still mounted
df
	verify the volume is not mounted
sudo mkfs /dev/vgdata/lvdata
	format with default filesystem (by not specifying one)
	answer y when prompted
sudo lsblk -f
	verify with lsblk which will show us the filsystem used

 - The only difference between ext2 and ext3 is the journal.
 - ext4 is recommended.
 - tune2fs can convert our filesystem from ext2 to ext3
	tune2fs also allows you to modify attributes of ext filesystems including
		- name
		- ID
		- how many times a filesystem can be mounted before checked
		- filesystem optimization settings

sudo tune2fs -j /dev/vgdata/lvdata
	-j creates the journal
sudo lsblk -f
	now we can see it's formatted as ext3
	you can go back and forth between these two without losing data

 - In recent versions of Linux, the ext4 driver is used to format all ext file systems.
 - Older systems had separate drivers for ext2 and 3.
 - You can migrate ext2 and ext3 to ext4 without losing data, in a one-way process.

sudo tune2fs -O extent,uninit_bg,dir_index /dev/vgdata/lvdata

extent = specifies using extent trees to store the location of data blocks
	this is an ext4 feature
uninit_bg = speeds up subsequent file system checks after the first one is completed
dir_index = uses hashed b-trees to speed up lookups for large directories

sudo e2fsck -fD /dev/vgdata/lvdata
	check the file system (5 passes)
sudo mount /dev/vgdata/lvdata /media/lvdata
	it's ready to be mounted
df -Th
	verify it's mounted, and file system type

==========

Repair EXT filesystems
----------------------

Corrupting the filesystem! 😈

[ Do not attempt on a production machine; test only ]

 - In order to fix the file system we'll need to break it first.
 - Make sure /dev/vgdata/lvdata is mounted as /media/lvdata.
	If not, then mount it:
		sudo mount /dev/vgdata/lvdata /media/lvdata/

sudo cp -Rvf / /media/lvdata
	Recursively copy a bunch of files to the volume.
	Let it run for a while and then kill the process with ctrl+c.
		You need a lot of files in the file system so you have a higher chance of corrupting one of them.
sudo dd if=/dev/zero bs=1 count=10 of=/dev/vgdata/lvdata seek=1000
	Using dd to copy zeros to random places on the file system.
	bs=1 -> block size is 1
	count=10 -> that'll be 10 blocks
	We're writing to the logical volume device, not to the file system.
	Run this multiple times and change the seek value each time.

sudo umount /media/lvdata
	unmount
sudo fsck -n /dev/vgdata/lvdata
	Run a file system check.
	Using -n will notify of corruption but not fix it.

Option		Function
fsck -A		Checks all file systems
fsck -AR	Checks all file systems except for the root
fsck -f		Force checks all file systems, even if they are considered clean
fsck -a		Fixes safe problems automatically.
		These are issues that don't need review from an administrator.
fsck -y		Answers all questions with a yes.
		This is not the same thing as -a
		There are some decisions that an administrator needs to make.